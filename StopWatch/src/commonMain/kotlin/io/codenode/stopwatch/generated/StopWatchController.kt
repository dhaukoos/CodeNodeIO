/*
 * StopWatch Controller
 * Generated by CodeNodeIO ModuleGenerator
 * License: Apache 2.0
 */

package io.codenode.stopwatch.generated

import io.codenode.fbpdsl.model.RootControlNode
import io.codenode.fbpdsl.model.FlowGraph
import io.codenode.fbpdsl.model.FlowExecutionStatus
import io.codenode.fbpdsl.model.ExecutionState
import io.codenode.fbpdsl.model.ControlConfig
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.LifecycleOwner
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

/**
 * Controller for StopWatch flow execution.
 *
 * Provides unified control operations for starting, pausing,
 * stopping, and monitoring the flow execution.
 *
 * This class wraps RootControlNode to provide a clean API
 * specific to the StopWatch flow.
 *
 * @param flowGraph The FlowGraph instance to control
 * @generated by CodeNodeIO ModuleGenerator
 */
class StopWatchController(
    private var flowGraph: FlowGraph
) {

    private var controller: RootControlNode = RootControlNode.createFor(
        flowGraph = flowGraph,
        name = "StopWatchController"
    )

    private val flow = StopWatchFlow()

    /**
     * Tracks whether the flow was running before a lifecycle-triggered pause.
     * Used to restore running state when lifecycle resumes.
     */
    private var wasRunningBeforePause: Boolean = false

    // Observable state properties
    private val _elapsedSeconds = MutableStateFlow(0)
    /**
     * Current elapsed seconds as observable StateFlow.
     * Updates when the timer ticks.
     */
    val elapsedSeconds: StateFlow<Int> = _elapsedSeconds.asStateFlow()

    private val _elapsedMinutes = MutableStateFlow(0)
    /**
     * Current elapsed minutes as observable StateFlow.
     * Updates when seconds roll over to a new minute.
     */
    val elapsedMinutes: StateFlow<Int> = _elapsedMinutes.asStateFlow()

    private val _executionState = MutableStateFlow(ExecutionState.IDLE)
    /**
     * Current execution state as observable StateFlow.
     * Updates when start(), stop(), pause(), or reset() is called.
     */
    val executionState: StateFlow<ExecutionState> = _executionState.asStateFlow()

    /**
     * Starts all nodes in the flow.
     *
     * Transitions all nodes to RUNNING state.
     * State propagates to descendants respecting independentControl flags.
     *
     * @return Updated FlowGraph with all nodes running
     */
    fun start(): FlowGraph {
        flowGraph = controller.startAll()
        controller = RootControlNode.createFor(flowGraph, "StopWatchController")
        _executionState.value = ExecutionState.RUNNING
        return flowGraph
    }

    /**
     * Pauses all nodes in the flow.
     *
     * Transitions all nodes to PAUSED state.
     * State propagates to descendants respecting independentControl flags.
     *
     * @return Updated FlowGraph with all nodes paused
     */
    fun pause(): FlowGraph {
        flowGraph = controller.pauseAll()
        controller = RootControlNode.createFor(flowGraph, "StopWatchController")
        _executionState.value = ExecutionState.PAUSED
        return flowGraph
    }

    /**
     * Stops all nodes in the flow.
     *
     * Transitions all nodes to IDLE state.
     * State propagates to descendants respecting independentControl flags.
     *
     * @return Updated FlowGraph with all nodes stopped
     */
    fun stop(): FlowGraph {
        flowGraph = controller.stopAll()
        controller = RootControlNode.createFor(flowGraph, "StopWatchController")
        _executionState.value = ExecutionState.IDLE
        return flowGraph
    }

    /**
     * Resets the flow to initial state.
     *
     * Stops all nodes and clears any accumulated state.
     * Equivalent to stop() but semantically represents a fresh start.
     *
     * @return Updated FlowGraph with all nodes reset to IDLE
     */
    fun reset(): FlowGraph {
        wasRunningBeforePause = false
        _elapsedSeconds.value = 0
        _elapsedMinutes.value = 0
        return stop()
    }

    /**
     * Gets the current execution status of all nodes.
     *
     * @return FlowExecutionStatus with node counts and overall state
     */
    fun getStatus(): FlowExecutionStatus {
        return controller.getStatus()
    }

    /**
     * Sets execution state for a specific node.
     *
     * @param nodeId The ID of the node to update
     * @param state The new execution state
     * @return Updated FlowGraph
     */
    fun setNodeState(nodeId: String, state: ExecutionState): FlowGraph {
        flowGraph = controller.setNodeState(nodeId, state)
        controller = RootControlNode.createFor(flowGraph, "StopWatchController")
        return flowGraph
    }

    /**
     * Sets control configuration for a specific node.
     *
     * @param nodeId The ID of the node to update
     * @param config The new control configuration
     * @return Updated FlowGraph
     */
    fun setNodeConfig(nodeId: String, config: ControlConfig): FlowGraph {
        flowGraph = controller.setNodeConfig(nodeId, config)
        controller = RootControlNode.createFor(flowGraph, "StopWatchController")
        return flowGraph
    }

    /**
     * Binds the flow execution to a Lifecycle (works on all KMP platforms).
     *
     * When the lifecycle enters ON_START, resumes if previously running.
     * When the lifecycle enters ON_STOP, pauses and tracks state.
     * When the lifecycle is ON_DESTROY, stops the flow completely.
     *
     * @param lifecycle The lifecycle to bind to
     */
    fun bindToLifecycle(lifecycle: Lifecycle) {
        lifecycle.addObserver(object : LifecycleEventObserver {
            override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) {
                when (event) {
                    Lifecycle.Event.ON_START -> {
                        if (wasRunningBeforePause) {
                            start()
                            wasRunningBeforePause = false
                        }
                    }
                    Lifecycle.Event.ON_STOP -> {
                        val status = getStatus()
                        wasRunningBeforePause = status.overallState == ExecutionState.RUNNING
                        if (wasRunningBeforePause) {
                            pause()
                        }
                    }
                    Lifecycle.Event.ON_DESTROY -> {
                        stop()
                    }
                    else -> { /* no-op */ }
                }
            }
        })
    }

    /**
     * Gets the current FlowGraph state.
     */
    val currentFlowGraph: FlowGraph
        get() = flowGraph
}
