/*
 * StopWatch Controller
 * Generated by CodeNodeIO ModuleGenerator
 * License: Apache 2.0
 */

package io.codenode.stopwatch.generated

import io.codenode.fbpdsl.model.RootControlNode
import io.codenode.fbpdsl.model.FlowGraph
import io.codenode.fbpdsl.model.FlowExecutionStatus
import io.codenode.fbpdsl.model.ExecutionState
import io.codenode.fbpdsl.model.ControlConfig
import io.codenode.fbpdsl.runtime.RuntimeRegistry
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.LifecycleOwner
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

/**
 * Controller for StopWatch flow execution.
 *
 * Provides unified control operations for starting, pausing,
 * stopping, and monitoring the flow execution.
 *
 * This class wraps RootControlNode to provide a clean API
 * specific to the StopWatch flow.
 *
 * @param flowGraph The FlowGraph instance to control
 * @generated by CodeNodeIO ModuleGenerator
 */
class StopWatchController(
    private var flowGraph: FlowGraph
) {

    /**
     * RuntimeRegistry for centralized lifecycle management.
     * Tracks all active NodeRuntime instances and propagates pause/resume/stop commands.
     */
    private val registry = RuntimeRegistry()

    private var controller: RootControlNode = RootControlNode.createFor(
        flowGraph = flowGraph,
        name = "StopWatchController",
        registry = registry
    )

    private val flow = StopWatchFlow()

    /**
     * CoroutineScope for running the flow. Created on start, cancelled on stop.
     */
    private var flowScope: CoroutineScope? = null

    /**
     * Tracks whether the flow was running before a lifecycle-triggered pause.
     * Used to restore running state when lifecycle resumes.
     */
    private var wasRunningBeforePause: Boolean = false

    /**
     * Current seconds as observable StateFlow.
     * Updates when the timer ticks.
     * Directly observes the DisplayReceiverComponent's state.
     */
    val seconds: StateFlow<Int> = flow.displayReceiver.secondsFlow

    /**
     * Current minutes as observable StateFlow.
     * Updates when seconds roll over to a new minute.
     * Directly observes the DisplayReceiverComponent's state.
     */
    val minutes: StateFlow<Int> = flow.displayReceiver.minutesFlow

    private val _executionState = MutableStateFlow(ExecutionState.IDLE)
    /**
     * Current execution state as observable StateFlow.
     * Updates when start(), stop(), pause(), or reset() is called.
     */
    val executionState: StateFlow<ExecutionState> = _executionState.asStateFlow()

    /**
     * Starts all nodes in the flow.
     *
     * Transitions all nodes to RUNNING state and starts the actual flow execution.
     * State propagates to descendants respecting independentControl flags.
     *
     * @return Updated FlowGraph with all nodes running
     */
    fun start(): FlowGraph {
        // Update FlowGraph state model via RootControlNode
        flowGraph = controller.startAll()
        controller = RootControlNode.createFor(flowGraph, "StopWatchController", registry)
        _executionState.value = ExecutionState.RUNNING

        // Cancel any existing scope and create a new one
        flowScope?.cancel()
        val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)
        flowScope = scope

        // Wire registry to flow components for centralized lifecycle control
        flow.timerEmitter.registry = registry
        flow.displayReceiver.registry = registry

        // Set the timer emitter to RUNNING and start the flow
        flow.timerEmitter.executionState = ExecutionState.RUNNING
        scope.launch {
            flow.start(scope)
        }

        return flowGraph
    }

    /**
     * Pauses all nodes in the flow.
     *
     * Transitions all nodes to PAUSED state.
     * State propagates to descendants respecting independentControl flags.
     *
     * @return Updated FlowGraph with all nodes paused
     */
    fun pause(): FlowGraph {
        // Pause via RootControlNode - this updates model state AND calls registry.pauseAll()
        flowGraph = controller.pauseAll()
        controller = RootControlNode.createFor(flowGraph, "StopWatchController", registry)
        _executionState.value = ExecutionState.PAUSED
        return flowGraph
    }

    /**
     * Resumes all nodes in the flow from paused state.
     *
     * Transitions all nodes back to RUNNING state.
     * State propagates to descendants respecting independentControl flags.
     *
     * @return Updated FlowGraph with all nodes running
     */
    fun resume(): FlowGraph {
        // Resume via RootControlNode - this updates model state AND calls registry.resumeAll()
        flowGraph = controller.resumeAll()
        controller = RootControlNode.createFor(flowGraph, "StopWatchController", registry)
        _executionState.value = ExecutionState.RUNNING
        return flowGraph
    }

    /**
     * Stops all nodes in the flow.
     *
     * Transitions all nodes to IDLE state and stops the actual flow execution.
     * State propagates to descendants respecting independentControl flags.
     *
     * @return Updated FlowGraph with all nodes stopped
     */
    fun stop(): FlowGraph {
        // Stop via RootControlNode - this updates model state AND calls registry.stopAll()
        // which stops all registered runtimes
        flowGraph = controller.stopAll()
        controller = RootControlNode.createFor(flowGraph, "StopWatchController", registry)
        _executionState.value = ExecutionState.IDLE

        // Stop the actual flow execution and cancel scope
        flow.stop()
        flowScope?.cancel()
        flowScope = null

        return flowGraph
    }

    /**
     * Resets the flow to initial state.
     *
     * Stops all nodes and clears any accumulated state.
     * Equivalent to stop() but semantically represents a fresh start.
     *
     * @return Updated FlowGraph with all nodes reset to IDLE
     */
    fun reset(): FlowGraph {
        wasRunningBeforePause = false
        // Reset the timer component state
        flow.timerEmitter.reset()
        return stop()
    }

    /**
     * Gets the current execution status of all nodes.
     *
     * @return FlowExecutionStatus with node counts and overall state
     */
    fun getStatus(): FlowExecutionStatus {
        return controller.getStatus()
    }

    /**
     * Sets execution state for a specific node.
     *
     * @param nodeId The ID of the node to update
     * @param state The new execution state
     * @return Updated FlowGraph
     */
    fun setNodeState(nodeId: String, state: ExecutionState): FlowGraph {
        flowGraph = controller.setNodeState(nodeId, state)
        controller = RootControlNode.createFor(flowGraph, "StopWatchController")
        return flowGraph
    }

    /**
     * Sets control configuration for a specific node.
     *
     * @param nodeId The ID of the node to update
     * @param config The new control configuration
     * @return Updated FlowGraph
     */
    fun setNodeConfig(nodeId: String, config: ControlConfig): FlowGraph {
        flowGraph = controller.setNodeConfig(nodeId, config)
        controller = RootControlNode.createFor(flowGraph, "StopWatchController")
        return flowGraph
    }

    /**
     * Binds the flow execution to a Lifecycle (works on all KMP platforms).
     *
     * When the lifecycle enters ON_START, resumes if previously running.
     * When the lifecycle enters ON_STOP, pauses and tracks state.
     * When the lifecycle is ON_DESTROY, stops the flow completely.
     *
     * @param lifecycle The lifecycle to bind to
     */
    fun bindToLifecycle(lifecycle: Lifecycle) {
        lifecycle.addObserver(object : LifecycleEventObserver {
            override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) {
                when (event) {
                    Lifecycle.Event.ON_START -> {
                        if (wasRunningBeforePause) {
                            start()
                            wasRunningBeforePause = false
                        }
                    }
                    Lifecycle.Event.ON_STOP -> {
                        val status = getStatus()
                        wasRunningBeforePause = status.overallState == ExecutionState.RUNNING
                        if (wasRunningBeforePause) {
                            pause()
                        }
                    }
                    Lifecycle.Event.ON_DESTROY -> {
                        stop()
                    }
                    else -> { /* no-op */ }
                }
            }
        })
    }

    /**
     * Gets the current FlowGraph state.
     */
    val currentFlowGraph: FlowGraph
        get() = flowGraph
}
