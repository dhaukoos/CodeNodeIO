/*
 * StopWatch Flow
 * Generated by CodeNodeIO ModuleGenerator
 * License: Apache 2.0
 */

package io.codenode.stopwatch.generated

import io.codenode.stopwatch.usecases.TimerEmitterComponent
import io.codenode.stopwatch.usecases.DisplayReceiverComponent
import io.codenode.stopwatch.usecases.TimerOutput

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.channels.Channel

/**
 * Flow orchestrator for: StopWatch
 *
 * Version: 1.0.0
 * Description: Virtual circuit demo for stopwatch functionality
 *
 * Nodes: 2
 * Connections: 1 (Channel-based with backpressure)
 *
 * @generated by CodeNodeIO ModuleGenerator
 */
class StopWatchFlow {

    // Node components (internal for controller access)
    internal val timerEmitter = TimerEmitterComponent()
    internal val displayReceiver = DisplayReceiverComponent()

    // Connection channels (using typed Kotlin Channel for FBP point-to-point semantics)
    private val channel_conn_1 = Channel<TimerOutput>(Channel.RENDEZVOUS)

    /**
     * Starts the flow with the given coroutine scope.
     *
     * @param scope The coroutine scope to run in
     */
    suspend fun start(scope: CoroutineScope) {
        wireConnections()
        timerEmitter.start(scope)
        displayReceiver.start(scope)
    }

    /**
     * Stops all components in the flow.
     * Closes channels first for graceful shutdown, then stops components.
     */
    fun stop() {
        // Close channels first (graceful shutdown)
        channel_conn_1.close()

        // Stop components
        timerEmitter.stop()
        displayReceiver.stop()
    }

    /**
     * Wires up connections between components.
     * Assigns channels to component SendChannel/ReceiveChannel properties.
     */
    private fun wireConnections() {
        // TimerEmitter -> DisplayReceiver
        timerEmitter.outputChannel = channel_conn_1
        displayReceiver.inputChannel = channel_conn_1
    }
}

