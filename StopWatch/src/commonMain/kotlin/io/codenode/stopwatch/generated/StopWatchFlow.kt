/*
 * StopWatch Flow
 * Generated by CodeNodeIO ModuleGenerator
 * License: Apache 2.0
 */

package io.codenode.stopwatch.generated

import io.codenode.stopwatch.usecases.TimerEmitterComponent
import io.codenode.stopwatch.usecases.DisplayReceiverComponent
import io.codenode.stopwatch.usecases.TimerOutput

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.launch

/**
 * Flow orchestrator for: StopWatch
 *
 * Version: 1.0.0
 * Description: Virtual circuit demo for stopwatch functionality
 *
 * Nodes: 2
 * Connections: 2
 *
 * @generated by CodeNodeIO ModuleGenerator
 */
class StopWatchFlow {

    // Node components (internal for controller access)
    internal val timerEmitter = TimerEmitterComponent()
    internal val displayReceiver = DisplayReceiverComponent()

    // Connection channels
    private val channel_conn_1770875159420_3821 = MutableSharedFlow<Any>(replay = 1)
    private val channel_conn_1770875159422_6258 = MutableSharedFlow<Any>(replay = 1)

    /**
     * Starts the flow with the given coroutine scope.
     *
     * @param scope The coroutine scope to run in
     */
    suspend fun start(scope: CoroutineScope) {
        wireConnections(scope)
        timerEmitter.start(scope)
        displayReceiver.start(scope)
    }

    /**
     * Stops all components in the flow.
     */
    fun stop() {
        timerEmitter.stop()
        displayReceiver.stop()
    }

    /**
     * Wires up connections between components.
     */
    private fun wireConnections(scope: CoroutineScope) {
        // TimerEmitter -> DisplayReceiver
        scope.launch {
            timerEmitter.output.collect { data ->
                displayReceiver.input.emit(data)
            }
        }
        // TimerEmitter -> DisplayReceiver
        scope.launch {
            timerEmitter.output.collect { data ->
                displayReceiver.input.emit(data)
            }
        }
    }
}

