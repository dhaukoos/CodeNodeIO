/*
 * StopWatch Flow
 * Generated by CodeNodeIO ModuleGenerator
 * License: Apache 2.0
 */

package io.codenode.stopwatch.generated

import io.codenode.stopwatch.usecases.TimerEmitterComponent
import io.codenode.stopwatch.usecases.DisplayReceiverComponent

import kotlinx.coroutines.CoroutineScope

/**
 * Flow orchestrator for: StopWatch
 *
 * Version: 1.0.0
 * Description: Virtual circuit demo for stopwatch functionality
 *
 * Nodes: 2
 * Connections: 2 (Typed Channel-based with backpressure - seconds and minutes)
 *
 * @generated by CodeNodeIO ModuleGenerator
 */
class StopWatchFlow {

    // Node components (internal for controller access)
    internal val timerEmitter = TimerEmitterComponent()
    internal val displayReceiver = DisplayReceiverComponent()

    // Out2GeneratorRuntime creates its own output channels internally,
    // so we wire the sink inputs directly to the generator outputs.

    /**
     * Starts the flow with the given coroutine scope.
     *
     * @param scope The coroutine scope to run in
     */
    suspend fun start(scope: CoroutineScope) {
        // Start generator first so it recreates its output channels
        timerEmitter.start(scope)
        // Wire connections after channels are recreated
        wireConnections()
        displayReceiver.start(scope)
    }

    /**
     * Stops all components in the flow.
     * Generator's output channels are closed internally when it stops.
     */
    fun stop() {
        // Stop components (generator closes its channels on stop)
        timerEmitter.stop()
        displayReceiver.stop()
    }

    /**
     * Wires up connections between components.
     * Connects displayReceiver's inputs to timerEmitter's outputs.
     */
    private fun wireConnections() {
        // TimerEmitter (Out2Generator) -> DisplayReceiver (In2Sink)
        // outputChannel1: seconds, outputChannel2: minutes
        displayReceiver.inputChannel = timerEmitter.outputChannel1
        displayReceiver.inputChannel2 = timerEmitter.outputChannel2
    }
}

