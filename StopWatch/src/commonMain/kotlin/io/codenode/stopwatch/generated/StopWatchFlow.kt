/*
 * StopWatch Flow
 * Generated by CodeNodeIO ModuleGenerator
 * License: Apache 2.0
 */

package io.codenode.stopwatch.generated

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.launch
import io.codenode.fbpdsl.model.FlowGraph
import io.codenode.fbpdsl.model.CodeNode
import io.codenode.fbpdsl.model.CodeNodeType
import io.codenode.fbpdsl.model.Node
import io.codenode.fbpdsl.model.Port
import io.codenode.fbpdsl.model.Connection
import io.codenode.stopwatch.usecases.TimerEmitterComponent
import io.codenode.stopwatch.usecases.DisplayReceiverComponent
import io.codenode.stopwatch.usecases.TimerOutput

/**
 * Flow orchestrator for: StopWatch
 *
 * Version: 1.0.0
 * Description: Virtual circuit demo for stopwatch functionality
 *
 * Nodes: 2
 * Connections: 2
 *
 * @generated by CodeNodeIO ModuleGenerator
 */
class StopWatchFlow {

    // Node components
    private val timerEmitter = TimerEmitterComponent()
    private val displayReceiver = DisplayReceiverComponent()

    // Connection channels
    private val channel_conn_1770875159420_3821 = MutableSharedFlow<Any>(replay = 1)
    private val channel_conn_1770875159422_6258 = MutableSharedFlow<Any>(replay = 1)

    /**
     * Starts the flow with the given coroutine scope.
     *
     * @param scope The coroutine scope to run in
     */
    suspend fun start(scope: CoroutineScope) {
        wireConnections(scope)
        timerEmitter.start(scope)
        displayReceiver.start(scope)
    }

    /**
     * Stops all components in the flow.
     */
    fun stop() {
        timerEmitter.stop()
        displayReceiver.stop()
    }

    /**
     * Wires up connections between components.
     */
    private fun wireConnections(scope: CoroutineScope) {
        // TimerEmitter -> DisplayReceiver
        scope.launch {
            timerEmitter.output.collect { data ->
                displayReceiver.input.emit(data)
            }
        }
        // TimerEmitter -> DisplayReceiver
        scope.launch {
            timerEmitter.output.collect { data ->
                displayReceiver.input.emit(data)
            }
        }
    }
}

// ========== FlowGraph Factory Function ==========

/**
 * Creates a StopWatch FlowGraph with all nodes, ports, connections,
 * and ProcessingLogic implementations.
 *
 * Version: 1.0.0
 * Description: Virtual circuit demo for stopwatch functionality
 *
 * @return Fully configured FlowGraph ready for execution
 * @generated by CodeNodeIO FlowGraphFactoryGenerator
 */
public fun createStopWatchFlowGraph(): io.codenode.fbpdsl.model.FlowGraph {
  val timerEmitter = CodeNode(
    id = "node_1770875159380_2079",
    name = "TimerEmitter",
    codeNodeType = CodeNodeType.CUSTOM,
    position = Node.Position(100.0, 100.0),
    inputPorts = emptyList(),
    outputPorts = listOf(
      Port(
        id = "port_1770875159390_3123_elapsedSeconds",
        name = "elapsedSeconds",
        direction = Port.Direction.OUTPUT,
        dataType = Any::class,
        owningNodeId = "node_1770875159380_2079"
      ),
      Port(
        id = "port_1770875159406_3495_elapsedMinutes",
        name = "elapsedMinutes",
        direction = Port.Direction.OUTPUT,
        dataType = Any::class,
        owningNodeId = "node_1770875159380_2079"
      )
    ),
    configuration = mapOf(
      "speedAttenuation" to "1000",
      "_useCaseClass" to "io.codenode.stopwatch.usecases.TimerEmitterComponent"
    ),
    processingLogic = TimerEmitterComponent()
  )

  val displayReceiver = CodeNode(
    id = "node_1770875159414_5237",
    name = "DisplayReceiver",
    codeNodeType = CodeNodeType.CUSTOM,
    position = Node.Position(400.0, 100.0),
    inputPorts = listOf(
      Port(
        id = "port_1770875159414_670_seconds",
        name = "seconds",
        direction = Port.Direction.INPUT,
        dataType = Any::class,
        owningNodeId = "node_1770875159414_5237"
      ),
      Port(
        id = "port_1770875159414_9992_minutes",
        name = "minutes",
        direction = Port.Direction.INPUT,
        dataType = Any::class,
        owningNodeId = "node_1770875159414_5237"
      )
    ),
    outputPorts = emptyList(),
    configuration = mapOf(
      "_useCaseClass" to "io.codenode.stopwatch.usecases.DisplayReceiverComponent"
    ),
    processingLogic = DisplayReceiverComponent()
  )

  val connections = listOf(
    Connection(
      id = "conn_1770875159420_3821",
      sourceNodeId = "node_1770875159380_2079",
      sourcePortId = "port_1770875159390_3123_elapsedSeconds",
      targetNodeId = "node_1770875159414_5237",
      targetPortId = "port_1770875159414_670_seconds",
      channelCapacity = 0
    ),
    Connection(
      id = "conn_1770875159422_6258",
      sourceNodeId = "node_1770875159380_2079",
      sourcePortId = "port_1770875159406_3495_elapsedMinutes",
      targetNodeId = "node_1770875159414_5237",
      targetPortId = "port_1770875159414_9992_minutes",
      channelCapacity = 0
    )
  )

  return FlowGraph(
    id = "graph_1770875159422_279723",
    name = "StopWatch",
    version = "1.0.0",
    description = "Virtual circuit demo for stopwatch functionality",
    rootNodes = listOf(timerEmitter, displayReceiver),
    connections = connections,
    targetPlatforms = emptyList()
  )
}
