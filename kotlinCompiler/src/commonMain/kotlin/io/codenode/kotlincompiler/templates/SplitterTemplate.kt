/*
 * Splitter Node Template
 * Generates code for data splitting/routing nodes
 * License: Apache 2.0
 */

package io.codenode.kotlincompiler.templates

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import io.codenode.fbpdsl.model.CodeNode
import io.codenode.fbpdsl.model.CodeNodeType
import io.codenode.kotlincompiler.generator.camelCase

/**
 * Template for generating Splitter node components.
 *
 * Splitters take single input and route to one or more output ports
 * based on routing logic. They can duplicate data or route selectively.
 *
 * Generated code pattern:
 * ```kotlin
 * class MySplitter {
 *     val input = MutableSharedFlow<Any>()
 *     val outputA = MutableSharedFlow<Any>()
 *     val outputB = MutableSharedFlow<Any>()
 *
 *     fun route(data: Any?): Set<String>
 *
 *     fun start(scope: CoroutineScope) {
 *         scope.launch {
 *             input.collect { data ->
 *                 val targets = route(data)
 *                 targets.forEach { target ->
 *                     when(target) {
 *                         "outputA" -> outputA.emit(data)
 *                         "outputB" -> outputB.emit(data)
 *                     }
 *                 }
 *             }
 *         }
 *     }
 * }
 * ```
 */
class SplitterTemplate : NodeTemplate {

    override val nodeType = CodeNodeType.SPLITTER

    override fun generate(node: CodeNode, className: ClassName): TypeSpec {
        val classBuilder = TypeSpec.classBuilder(className)
            .addKdoc(generateKDoc(node))

        val flowType = ClassName("kotlinx.coroutines.flow", "MutableSharedFlow")
            .parameterizedBy(ANY)

        // Input flow
        val inputName = if (node.inputPorts.isNotEmpty()) {
            node.inputPorts.first().name.camelCase()
        } else {
            "input"
        }
        classBuilder.addProperty(
            PropertySpec.builder("${inputName}Input", flowType)
                .initializer("%T()", ClassName("kotlinx.coroutines.flow", "MutableSharedFlow"))
                .build()
        )

        // Output flows for each output port
        val outputNames = if (node.outputPorts.isNotEmpty()) {
            node.outputPorts.map { it.name.camelCase() }
        } else {
            listOf("outputA", "outputB")
        }

        outputNames.forEach { outputName ->
            classBuilder.addProperty(
                PropertySpec.builder("${outputName}Output", flowType)
                    .initializer("%T()", ClassName("kotlinx.coroutines.flow", "MutableSharedFlow"))
                    .build()
            )
        }

        // Add route function
        classBuilder.addFunction(generateRouteFunction(outputNames))

        // Add start function
        classBuilder.addFunction(generateStartFunction(inputName, outputNames))

        return classBuilder.build()
    }

    private fun generateKDoc(node: CodeNode): CodeBlock {
        return CodeBlock.builder()
            .add("Splitter component: ${node.name}\n")
            .add("\n")
            .add("Routes input data to one or more output ports.\n")
            .apply {
                node.description?.let { add("\n$it\n") }
            }
            .add("\n")
            .add("@generated by CodeNodeIO KotlinCompiler\n")
            .build()
    }

    private fun generateRouteFunction(outputNames: List<String>): FunSpec {
        val setType = SET.parameterizedBy(STRING)

        return FunSpec.builder("route")
            .addModifiers(KModifier.OPEN)
            .addParameter("data", ANY.copy(nullable = true))
            .returns(setType)
            .addKdoc("Determines which output ports should receive the data.\n")
            .addKdoc("\n")
            .addKdoc("Override this method to implement custom routing logic.\n")
            .addKdoc("Return a set of output port names to send data to.\n")
            .addKdoc("\n")
            .addKdoc("Available outputs: ${outputNames.joinToString(", ")}\n")
            .addKdoc("\n")
            .addKdoc("@param data The input data to route\n")
            .addKdoc("@return Set of output port names to send data to\n")
            .addCode(CodeBlock.builder()
                .addStatement("// TODO: Implement routing logic")
                .addStatement("// Return names of outputs to send data to")
                .addStatement("return setOf(${outputNames.joinToString(", ") { "\"$it\"" }})")
                .build())
            .build()
    }

    private fun generateStartFunction(inputName: String, outputNames: List<String>): FunSpec {
        val scopeType = ClassName("kotlinx.coroutines", "CoroutineScope")

        return FunSpec.builder("start")
            .addParameter("scope", scopeType)
            .addKdoc("Starts the splitter's processing loop.\n")
            .addCode(CodeBlock.builder()
                .beginControlFlow("scope.launch")
                .beginControlFlow("${inputName}Input.collect { data ->")
                .addStatement("val targets = route(data)")
                .beginControlFlow("targets.forEach { target ->")
                .beginControlFlow("when (target)")
                .apply {
                    outputNames.forEach { outputName ->
                        addStatement("\"$outputName\" -> ${outputName}Output.emit(data)")
                    }
                }
                .endControlFlow()
                .endControlFlow()
                .endControlFlow()
                .endControlFlow()
                .build())
            .build()
    }
}
