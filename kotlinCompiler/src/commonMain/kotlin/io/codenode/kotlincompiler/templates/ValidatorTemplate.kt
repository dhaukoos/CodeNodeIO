/*
 * Validator Node Template
 * Generates code for data validation nodes
 * License: Apache 2.0
 */

package io.codenode.kotlincompiler.templates

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import io.codenode.fbpdsl.model.CodeNode
import io.codenode.fbpdsl.model.CodeNodeType
import io.codenode.kotlincompiler.generator.camelCase
import io.codenode.kotlincompiler.generator.ConfigAwareGenerator

/**
 * Template for generating Validator node components.
 *
 * Validators check input data against validation rules and route
 * data to either valid or invalid output ports based on results.
 *
 * Generated code pattern:
 * ```kotlin
 * class MyValidator {
 *     val input = MutableSharedFlow<Any>()
 *     val validOutput = MutableSharedFlow<Any>()
 *     val invalidOutput = MutableSharedFlow<ValidationError>()
 *
 *     fun validate(data: Any?): ValidationResult
 *
 *     fun start(scope: CoroutineScope) {
 *         scope.launch {
 *             input.collect { data ->
 *                 val result = validate(data)
 *                 if (result.isValid) {
 *                     validOutput.emit(data)
 *                 } else {
 *                     invalidOutput.emit(result.error)
 *                 }
 *             }
 *         }
 *     }
 * }
 * ```
 */
class ValidatorTemplate : NodeTemplate {

    override val nodeType = CodeNodeType.VALIDATOR

    override fun generate(node: CodeNode, className: ClassName): TypeSpec {
        val classBuilder = TypeSpec.classBuilder(className)
            .addKdoc(generateKDoc(node))

        val flowType = ClassName("kotlinx.coroutines.flow", "MutableSharedFlow")
            .parameterizedBy(ANY)

        // Input flow
        val inputName = if (node.inputPorts.isNotEmpty()) {
            node.inputPorts.first().name.camelCase()
        } else {
            "input"
        }
        classBuilder.addProperty(
            PropertySpec.builder("${inputName}Input", flowType)
                .initializer("%T()", ClassName("kotlinx.coroutines.flow", "MutableSharedFlow"))
                .build()
        )

        // Valid output flow
        classBuilder.addProperty(
            PropertySpec.builder("validOutput", flowType)
                .initializer("%T()", ClassName("kotlinx.coroutines.flow", "MutableSharedFlow"))
                .addKdoc("Output for data that passes validation")
                .build()
        )

        // Invalid output flow
        classBuilder.addProperty(
            PropertySpec.builder("invalidOutput", flowType)
                .initializer("%T()", ClassName("kotlinx.coroutines.flow", "MutableSharedFlow"))
                .addKdoc("Output for data that fails validation (includes error info)")
                .build()
        )

        // Add configuration properties
        ConfigAwareGenerator.addConfigurationProperties(classBuilder, node)

        // Add ValidationResult inner class
        classBuilder.addType(generateValidationResultClass())

        // Add validate function
        classBuilder.addFunction(generateValidateFunction())

        // Add start function
        classBuilder.addFunction(generateStartFunction(inputName))

        return classBuilder.build()
    }

    private fun generateKDoc(node: CodeNode): CodeBlock {
        return CodeBlock.builder()
            .add("Validator component: ${node.name}\n")
            .add("\n")
            .add("Validates input data and routes to valid or invalid output.\n")
            .apply {
                node.description?.let { add("\n$it\n") }
            }
            .add("\n")
            .add("@generated by CodeNodeIO KotlinCompiler\n")
            .build()
    }

    private fun generateValidationResultClass(): TypeSpec {
        return TypeSpec.classBuilder("ValidationResult")
            .addModifiers(KModifier.DATA)
            .primaryConstructor(FunSpec.constructorBuilder()
                .addParameter("isValid", BOOLEAN)
                .addParameter(ParameterSpec.builder("errors", LIST.parameterizedBy(STRING))
                    .defaultValue("emptyList()")
                    .build())
                .addParameter(ParameterSpec.builder("data", ANY.copy(nullable = true))
                    .defaultValue("null")
                    .build())
                .build())
            .addProperty(PropertySpec.builder("isValid", BOOLEAN)
                .initializer("isValid")
                .build())
            .addProperty(PropertySpec.builder("errors", LIST.parameterizedBy(STRING))
                .initializer("errors")
                .build())
            .addProperty(PropertySpec.builder("data", ANY.copy(nullable = true))
                .initializer("data")
                .build())
            .addKdoc("Result of a validation operation.\n")
            .build()
    }

    private fun generateValidateFunction(): FunSpec {
        return FunSpec.builder("validate")
            .addModifiers(KModifier.OPEN)
            .addParameter("data", ANY.copy(nullable = true))
            .returns(ClassName("", "ValidationResult"))
            .addKdoc("Validates the input data.\n")
            .addKdoc("\n")
            .addKdoc("Override this method to implement custom validation rules.\n")
            .addKdoc("\n")
            .addKdoc("@param data The input data to validate\n")
            .addKdoc("@return ValidationResult with isValid flag and any errors\n")
            .addCode(CodeBlock.builder()
                .addStatement("// TODO: Implement validation rules")
                .addStatement("val errors = mutableListOf<String>()")
                .addStatement("")
                .beginControlFlow("if (data == null)")
                .addStatement("errors.add(\"Data cannot be null\")")
                .endControlFlow()
                .addStatement("")
                .addStatement("return ValidationResult(isValid = errors.isEmpty(), errors = errors, data = data)")
                .build())
            .build()
    }

    private fun generateStartFunction(inputName: String): FunSpec {
        val scopeType = ClassName("kotlinx.coroutines", "CoroutineScope")

        return FunSpec.builder("start")
            .addParameter("scope", scopeType)
            .addKdoc("Starts the validator's processing loop.\n")
            .addCode(CodeBlock.builder()
                .beginControlFlow("scope.launch")
                .beginControlFlow("${inputName}Input.collect { data ->")
                .addStatement("val result = validate(data)")
                .beginControlFlow("if (result.isValid)")
                .addStatement("validOutput.emit(data)")
                .nextControlFlow("else")
                .addStatement("invalidOutput.emit(mapOf(\"data\" to data, \"errors\" to result.errors))")
                .endControlFlow()
                .endControlFlow()
                .endControlFlow()
                .build())
            .build()
    }
}
