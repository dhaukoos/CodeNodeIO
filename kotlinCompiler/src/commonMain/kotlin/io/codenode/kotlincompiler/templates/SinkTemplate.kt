/*
 * Sink Node Template
 * Generates code for data sink nodes (endpoints)
 * License: Apache 2.0
 */

package io.codenode.kotlincompiler.templates

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import io.codenode.fbpdsl.model.CodeNode
import io.codenode.fbpdsl.model.CodeNodeType
import io.codenode.kotlincompiler.generator.camelCase

/**
 * Template for generating Sink node components.
 *
 * Sinks consume data without producing output. They are the endpoints
 * in a flow graph - loggers, database writers, API callers, etc.
 *
 * Generated code pattern:
 * ```kotlin
 * class MySink {
 *     val input = MutableSharedFlow<Any>()
 *
 *     suspend fun consume(data: Any?)
 *
 *     fun start(scope: CoroutineScope) {
 *         scope.launch {
 *             input.collect { data ->
 *                 consume(data)
 *             }
 *         }
 *     }
 * }
 * ```
 */
class SinkTemplate : NodeTemplate {

    override val nodeType = CodeNodeType.SINK

    override fun generate(node: CodeNode, className: ClassName): TypeSpec {
        val classBuilder = TypeSpec.classBuilder(className)
            .addKdoc(generateKDoc(node))

        val flowType = ClassName("kotlinx.coroutines.flow", "MutableSharedFlow")
            .parameterizedBy(ANY)

        // Input flows for each input port
        val inputNames = if (node.inputPorts.isNotEmpty()) {
            node.inputPorts.map { it.name.camelCase() }
        } else {
            listOf("input")
        }

        inputNames.forEach { inputName ->
            classBuilder.addProperty(
                PropertySpec.builder("${inputName}Input", flowType)
                    .initializer("%T()", ClassName("kotlinx.coroutines.flow", "MutableSharedFlow"))
                    .build()
            )
        }

        // Add processed count for monitoring
        classBuilder.addProperty(
            PropertySpec.builder("processedCount", LONG)
                .mutable()
                .addModifiers(KModifier.PRIVATE)
                .initializer("0L")
                .build()
        )

        // Add consume function
        classBuilder.addFunction(generateConsumeFunction())

        // Add start function
        classBuilder.addFunction(generateStartFunction(inputNames))

        // Add stats function
        classBuilder.addFunction(generateStatsFunction())

        return classBuilder.build()
    }

    private fun generateKDoc(node: CodeNode): CodeBlock {
        return CodeBlock.builder()
            .add("Sink component: ${node.name}\n")
            .add("\n")
            .add("Consumes data from the flow graph.\n")
            .add("This is an endpoint node - it has no outputs.\n")
            .apply {
                node.description?.let { add("\n$it\n") }
            }
            .add("\n")
            .add("@generated by CodeNodeIO KotlinCompiler\n")
            .build()
    }

    private fun generateConsumeFunction(): FunSpec {
        return FunSpec.builder("consume")
            .addModifiers(KModifier.SUSPEND, KModifier.OPEN)
            .addParameter("data", ANY.copy(nullable = true))
            .addKdoc("Consumes data from the flow.\n")
            .addKdoc("\n")
            .addKdoc("Override this method to implement custom consumption logic.\n")
            .addKdoc("Examples: logging, database writes, API calls, etc.\n")
            .addKdoc("\n")
            .addKdoc("@param data The data to consume\n")
            .addCode(CodeBlock.builder()
                .addStatement("// TODO: Implement consumption logic")
                .addStatement("println(\"Consumed: \$data\")")
                .addStatement("processedCount++")
                .build())
            .build()
    }

    private fun generateStartFunction(inputNames: List<String>): FunSpec {
        val scopeType = ClassName("kotlinx.coroutines", "CoroutineScope")

        return FunSpec.builder("start")
            .addParameter("scope", scopeType)
            .addKdoc("Starts the sink's consumption loop.\n")
            .addCode(CodeBlock.builder()
                .apply {
                    inputNames.forEach { inputName ->
                        beginControlFlow("scope.launch")
                        beginControlFlow("${inputName}Input.collect { data ->")
                        addStatement("consume(data)")
                        endControlFlow()
                        endControlFlow()
                        add("\n")
                    }
                }
                .build())
            .build()
    }

    private fun generateStatsFunction(): FunSpec {
        return FunSpec.builder("getStats")
            .returns(MAP.parameterizedBy(STRING, ANY))
            .addKdoc("Returns statistics about processed data.\n")
            .addCode(CodeBlock.builder()
                .addStatement("return mapOf(\"processedCount\" to processedCount)")
                .build())
            .build()
    }
}
