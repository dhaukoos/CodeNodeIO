/*
 * Generator Node Template
 * Generates code for data generation nodes (sources)
 * License: Apache 2.0
 */

package io.codenode.kotlincompiler.templates

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import io.codenode.fbpdsl.model.CodeNode
import io.codenode.fbpdsl.model.CodeNodeType
import io.codenode.kotlincompiler.generator.camelCase

/**
 * Template for generating Generator node components.
 *
 * Generators produce data without requiring input. They are the sources
 * in a flow graph - timers, API polls, user input listeners, etc.
 *
 * Generated code pattern:
 * ```kotlin
 * class MyGenerator {
 *     val output = MutableSharedFlow<Any>()
 *
 *     suspend fun generate(): Any?
 *
 *     fun start(scope: CoroutineScope) {
 *         scope.launch {
 *             while (isActive) {
 *                 val data = generate()
 *                 output.emit(data)
 *                 delay(interval)
 *             }
 *         }
 *     }
 * }
 * ```
 */
class GeneratorTemplate : NodeTemplate {

    override val nodeType = CodeNodeType.GENERATOR

    override fun generate(node: CodeNode, className: ClassName): TypeSpec {
        val classBuilder = TypeSpec.classBuilder(className)
            .addKdoc(generateKDoc(node))

        val flowType = ClassName("kotlinx.coroutines.flow", "MutableSharedFlow")
            .parameterizedBy(ANY)

        // Output flows for each output port
        val outputNames = if (node.outputPorts.isNotEmpty()) {
            node.outputPorts.map { it.name.camelCase() }
        } else {
            listOf("output")
        }

        outputNames.forEach { outputName ->
            classBuilder.addProperty(
                PropertySpec.builder("${outputName}Output", flowType)
                    .initializer("%T()", ClassName("kotlinx.coroutines.flow", "MutableSharedFlow"))
                    .build()
            )
        }

        // Add interval property for periodic generation
        classBuilder.addProperty(
            PropertySpec.builder("intervalMs", LONG)
                .mutable()
                .initializer("1000L")
                .addKdoc("Interval between generations in milliseconds")
                .build()
        )

        // Add running flag
        classBuilder.addProperty(
            PropertySpec.builder("isRunning", BOOLEAN)
                .mutable()
                .addModifiers(KModifier.PRIVATE)
                .initializer("false")
                .build()
        )

        // Add generate function
        classBuilder.addFunction(generateGenerateFunction())

        // Add start function
        classBuilder.addFunction(generateStartFunction(outputNames.first()))

        // Add stop function
        classBuilder.addFunction(generateStopFunction())

        return classBuilder.build()
    }

    private fun generateKDoc(node: CodeNode): CodeBlock {
        return CodeBlock.builder()
            .add("Generator component: ${node.name}\n")
            .add("\n")
            .add("Produces data for the flow graph.\n")
            .add("This is a source node - it has no inputs.\n")
            .apply {
                node.description?.let { add("\n$it\n") }
            }
            .add("\n")
            .add("@generated by CodeNodeIO KotlinCompiler\n")
            .build()
    }

    private fun generateGenerateFunction(): FunSpec {
        return FunSpec.builder("generate")
            .addModifiers(KModifier.SUSPEND, KModifier.OPEN)
            .returns(ANY.copy(nullable = true))
            .addKdoc("Generates data to emit.\n")
            .addKdoc("\n")
            .addKdoc("Override this method to implement custom generation logic.\n")
            .addKdoc("This method is called periodically based on intervalMs.\n")
            .addKdoc("\n")
            .addKdoc("@return The generated data to emit, or null to skip emission\n")
            .addCode(CodeBlock.builder()
                .addStatement("// TODO: Implement data generation logic")
                .addStatement("return System.currentTimeMillis() // Example: emit timestamps")
                .build())
            .build()
    }

    private fun generateStartFunction(outputName: String): FunSpec {
        val scopeType = ClassName("kotlinx.coroutines", "CoroutineScope")

        return FunSpec.builder("start")
            .addParameter("scope", scopeType)
            .addKdoc("Starts the generator's production loop.\n")
            .addCode(CodeBlock.builder()
                .addStatement("isRunning = true")
                .beginControlFlow("scope.launch")
                .beginControlFlow("while (isRunning)")
                .addStatement("val data = generate()")
                .beginControlFlow("if (data != null)")
                .addStatement("${outputName}Output.emit(data)")
                .endControlFlow()
                .addStatement("kotlinx.coroutines.delay(intervalMs)")
                .endControlFlow()
                .endControlFlow()
                .build())
            .build()
    }

    private fun generateStopFunction(): FunSpec {
        return FunSpec.builder("stop")
            .addKdoc("Stops the generator.\n")
            .addCode(CodeBlock.builder()
                .addStatement("isRunning = false")
                .build())
            .build()
    }
}
