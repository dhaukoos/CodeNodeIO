/*
 * RuntimeViewModelGenerator
 * Generates {Name}ViewModel.kt from FlowGraph
 * License: Apache 2.0
 */

package io.codenode.kotlincompiler.generator

import io.codenode.fbpdsl.model.FlowGraph

/**
 * Generates a {Name}ViewModel.kt file extending ViewModel and delegating
 * to the ControllerInterface.
 *
 * The generated ViewModel:
 * - Extends androidx.lifecycle.ViewModel
 * - Takes {Name}ControllerInterface as constructor param
 * - Delegates all StateFlow properties and control methods to the controller
 */
class RuntimeViewModelGenerator {

    private val observableStateResolver = ObservableStateResolver()

    /**
     * Generates the {Name}ViewModel.kt file content from a FlowGraph.
     *
     * @param flowGraph The flow graph to generate from
     * @param generatedPackage The package name for the generated file
     * @return Generated Kotlin source code
     */
    fun generate(flowGraph: FlowGraph, generatedPackage: String): String {
        val flowName = flowGraph.name.pascalCase()
        val observableProps = observableStateResolver.getObservableStateProperties(flowGraph)

        return buildString {
            generateHeader(flowName)
            generatePackage(generatedPackage)
            generateImports()
            appendLine()
            generateKDoc(flowName)
            appendLine("class ${flowName}ViewModel(")
            appendLine("    private val controller: ${flowName}ControllerInterface")
            appendLine(") : ViewModel() {")
            appendLine()

            if (observableProps.isNotEmpty()) {
                generateObservableStateDelegation(observableProps)
            }

            generateExecutionStateDelegation()
            generateMethodDelegations()

            appendLine("}")
            appendLine()
        }
    }

    private fun StringBuilder.generateHeader(flowName: String) {
        appendLine("/*")
        appendLine(" * ${flowName}ViewModel")
        appendLine(" * Generated by CodeNodeIO RuntimeViewModelGenerator")
        appendLine(" * License: Apache 2.0")
        appendLine(" */")
        appendLine()
    }

    private fun StringBuilder.generatePackage(generatedPackage: String) {
        appendLine("package $generatedPackage")
        appendLine()
    }

    private fun StringBuilder.generateImports() {
        appendLine("import androidx.lifecycle.ViewModel")
        appendLine("import io.codenode.fbpdsl.model.ExecutionState")
        appendLine("import io.codenode.fbpdsl.model.FlowGraph")
        appendLine("import kotlinx.coroutines.flow.StateFlow")
    }

    private fun StringBuilder.generateKDoc(flowName: String) {
        appendLine("/**")
        appendLine(" * ViewModel for the $flowName composable.")
        appendLine(" * Bridges FlowGraph domain logic with Compose UI.")
        appendLine(" *")
        appendLine(" * @param controller The ${flowName}ControllerInterface that manages FlowGraph execution")
        appendLine(" * @generated by CodeNodeIO RuntimeViewModelGenerator")
        appendLine(" */")
    }

    private fun StringBuilder.generateObservableStateDelegation(observableProps: List<ObservableProperty>) {
        observableProps.forEach { prop ->
            appendLine("    val ${prop.name}: StateFlow<${prop.typeName}> = controller.${prop.name}")
        }
        appendLine()
    }

    private fun StringBuilder.generateExecutionStateDelegation() {
        appendLine("    val executionState: StateFlow<ExecutionState> = controller.executionState")
        appendLine()
    }

    private fun StringBuilder.generateMethodDelegations() {
        appendLine("    fun start(): FlowGraph = controller.start()")
        appendLine()
        appendLine("    fun stop(): FlowGraph = controller.stop()")
        appendLine()
        appendLine("    fun reset(): FlowGraph = controller.reset()")
        appendLine()
        appendLine("    fun pause(): FlowGraph = controller.pause()")
        appendLine()
        appendLine("    fun resume(): FlowGraph = controller.resume()")
    }
}
