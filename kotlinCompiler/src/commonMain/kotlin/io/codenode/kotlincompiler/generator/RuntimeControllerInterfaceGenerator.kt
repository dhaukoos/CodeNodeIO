/*
 * RuntimeControllerInterfaceGenerator
 * Generates {Name}ControllerInterface.kt from FlowGraph
 * License: Apache 2.0
 */

package io.codenode.kotlincompiler.generator

import io.codenode.fbpdsl.model.FlowGraph

/**
 * Generates a {Name}ControllerInterface.kt file declaring the same control
 * methods and StateFlow properties as the Controller.
 *
 * The generated interface:
 * - Declares StateFlow properties for executionState and observable state
 * - Declares control method signatures (start, stop, reset, pause, resume)
 * - Enables dependency injection and testing with fakes
 */
class RuntimeControllerInterfaceGenerator {

    private val observableStateResolver = ObservableStateResolver()

    /**
     * Generates the {Name}ControllerInterface.kt file content from a FlowGraph.
     *
     * @param flowGraph The flow graph to generate from
     * @param generatedPackage The package name for the generated file
     * @return Generated Kotlin source code
     */
    fun generate(flowGraph: FlowGraph, generatedPackage: String): String {
        val flowName = flowGraph.name.pascalCase()
        val observableProps = observableStateResolver.getObservableStateProperties(flowGraph)

        return buildString {
            generateHeader(flowName)
            generatePackage(generatedPackage)
            generateImports()
            appendLine()
            generateKDoc(flowName)
            appendLine("interface ${flowName}ControllerInterface {")
            appendLine()

            if (observableProps.isNotEmpty()) {
                generateObservableStateDeclarations(observableProps)
            }

            generateExecutionStateDeclaration()
            generateMethodDeclarations(flowName)

            appendLine("}")
            appendLine()
        }
    }

    private fun StringBuilder.generateHeader(flowName: String) {
        appendLine("/*")
        appendLine(" * ${flowName}ControllerInterface")
        appendLine(" * Generated by CodeNodeIO RuntimeControllerInterfaceGenerator")
        appendLine(" * License: Apache 2.0")
        appendLine(" */")
        appendLine()
    }

    private fun StringBuilder.generatePackage(generatedPackage: String) {
        appendLine("package $generatedPackage")
        appendLine()
    }

    private fun StringBuilder.generateImports() {
        appendLine("import io.codenode.fbpdsl.model.ExecutionState")
        appendLine("import io.codenode.fbpdsl.model.FlowGraph")
        appendLine("import kotlinx.coroutines.flow.StateFlow")
    }

    private fun StringBuilder.generateKDoc(flowName: String) {
        appendLine("/**")
        appendLine(" * Interface defining the contract for $flowName controllers.")
        appendLine(" *")
        appendLine(" * Enables dependency injection and testing by allowing")
        appendLine(" * both the real ${flowName}Controller and test fakes to be used.")
        appendLine(" *")
        appendLine(" * @generated by CodeNodeIO RuntimeControllerInterfaceGenerator")
        appendLine(" */")
    }

    private fun StringBuilder.generateObservableStateDeclarations(observableProps: List<ObservableProperty>) {
        observableProps.forEach { prop ->
            appendLine("    val ${prop.name}: StateFlow<${prop.typeName}>")
        }
        appendLine()
    }

    private fun StringBuilder.generateExecutionStateDeclaration() {
        appendLine("    val executionState: StateFlow<ExecutionState>")
        appendLine()
    }

    private fun StringBuilder.generateMethodDeclarations(flowName: String) {
        appendLine("    fun start(): FlowGraph")
        appendLine()
        appendLine("    fun stop(): FlowGraph")
        appendLine()
        appendLine("    fun reset(): FlowGraph")
        appendLine()
        appendLine("    fun pause(): FlowGraph")
        appendLine()
        appendLine("    fun resume(): FlowGraph")
    }
}
