/*
 * Flow Generator
 * Generates connection/channel wiring code from FlowGraph connections
 * License: Apache 2.0
 */

package io.codenode.kotlincompiler.generator

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import io.codenode.fbpdsl.model.Connection
import io.codenode.fbpdsl.model.FlowGraph
import io.codenode.fbpdsl.model.CodeNode

/**
 * Generates Kotlin code for connecting FBP components using coroutines and channels.
 *
 * Creates an orchestrator class that:
 * - Instantiates all component classes
 * - Wires output flows to input flows based on connections
 * - Manages the lifecycle of the flow graph execution
 *
 * Generated code uses kotlinx.coroutines for async channel-based communication.
 */
class FlowGenerator {

    companion object {
        const val GENERATED_PACKAGE = "io.codenode.generated"
        const val FLOW_PACKAGE = "$GENERATED_PACKAGE.flow"
    }

    /**
     * Generates a flow orchestrator class that wires all components together.
     *
     * @param flowGraph The flow graph containing nodes and connections
     * @return FileSpec containing the orchestrator class
     */
    fun generateFlowOrchestrator(flowGraph: FlowGraph): FileSpec {
        val orchestratorName = "${flowGraph.name.pascalCase()}Flow"

        return FileSpec.builder(FLOW_PACKAGE, orchestratorName)
            .addType(generateOrchestratorClass(flowGraph, orchestratorName))
            .addImport("kotlinx.coroutines", "CoroutineScope", "launch", "coroutineScope")
            .addImport("kotlinx.coroutines.flow", "collect", "onEach")
            .build()
    }

    /**
     * Generates the orchestrator class definition.
     */
    private fun generateOrchestratorClass(flowGraph: FlowGraph, name: String): TypeSpec {
        val classBuilder = TypeSpec.classBuilder(name)
            .addKdoc(generateOrchestratorKDoc(flowGraph))

        // Add component instance properties
        flowGraph.getAllCodeNodes().forEach { node ->
            classBuilder.addProperty(generateComponentProperty(node))
        }

        // Add the main start function
        classBuilder.addFunction(generateStartFunction(flowGraph))

        // Add stop function
        classBuilder.addFunction(generateStopFunction())

        // Add connection wiring function
        classBuilder.addFunction(generateWireConnectionsFunction(flowGraph))

        return classBuilder.build()
    }

    /**
     * Generates KDoc for the orchestrator class.
     */
    private fun generateOrchestratorKDoc(flowGraph: FlowGraph): CodeBlock {
        return CodeBlock.builder()
            .add("Flow orchestrator for: ${flowGraph.name}\n")
            .add("\n")
            .add("Version: ${flowGraph.version}\n")
            .apply {
                flowGraph.description?.let { add("Description: $it\n") }
            }
            .add("\n")
            .add("Nodes: ${flowGraph.getAllCodeNodes().size}\n")
            .add("Connections: ${flowGraph.connections.size}\n")
            .add("\n")
            .add("@generated by CodeNodeIO KotlinCompiler\n")
            .build()
    }

    /**
     * Generates a property for a component instance.
     */
    private fun generateComponentProperty(node: CodeNode): PropertySpec {
        val componentClassName = ClassName(
            ComponentGenerator.COMPONENTS_PACKAGE,
            node.name.pascalCase()
        )

        return PropertySpec.builder(
            node.name.camelCase(),
            componentClassName
        )
            .initializer("%T()", componentClassName)
            .addKdoc("Component instance for node: ${node.name}")
            .build()
    }

    /**
     * Generates the main start function that launches all components.
     */
    private fun generateStartFunction(flowGraph: FlowGraph): FunSpec {
        val scopeType = ClassName("kotlinx.coroutines", "CoroutineScope")

        return FunSpec.builder("start")
            .addModifiers(KModifier.SUSPEND)
            .addParameter("scope", scopeType)
            .addKdoc("Starts all components and establishes connections.\n")
            .addKdoc("\n")
            .addKdoc("@param scope The coroutine scope to run in\n")
            .addCode(CodeBlock.builder()
                .addStatement("// Wire up connections between components")
                .addStatement("wireConnections(scope)")
                .addStatement("")
                .addStatement("// Start all components")
                .apply {
                    flowGraph.getAllCodeNodes().forEach { node ->
                        addStatement("${node.name.camelCase()}.start(scope)")
                    }
                }
                .build())
            .build()
    }

    /**
     * Generates the stop function.
     */
    private fun generateStopFunction(): FunSpec {
        return FunSpec.builder("stop")
            .addKdoc("Stops all components and cleans up resources.\n")
            .addCode(CodeBlock.builder()
                .addStatement("// TODO: Implement graceful shutdown")
                .addStatement("// Cancel coroutines and close channels")
                .build())
            .build()
    }

    /**
     * Generates the function that wires connections between components.
     */
    private fun generateWireConnectionsFunction(flowGraph: FlowGraph): FunSpec {
        val scopeType = ClassName("kotlinx.coroutines", "CoroutineScope")

        return FunSpec.builder("wireConnections")
            .addModifiers(KModifier.PRIVATE)
            .addParameter("scope", scopeType)
            .addKdoc("Establishes data flow connections between components.\n")
            .addCode(generateConnectionWiring(flowGraph))
            .build()
    }

    /**
     * Generates code to wire all connections.
     */
    private fun generateConnectionWiring(flowGraph: FlowGraph): CodeBlock {
        val codeBuilder = CodeBlock.builder()

        if (flowGraph.connections.isEmpty()) {
            codeBuilder.addStatement("// No connections to wire")
            return codeBuilder.build()
        }

        flowGraph.connections.forEach { connection ->
            codeBuilder.add(generateSingleConnection(connection, flowGraph))
        }

        return codeBuilder.build()
    }

    /**
     * Generates code for a single connection.
     */
    private fun generateSingleConnection(connection: Connection, flowGraph: FlowGraph): CodeBlock {
        val sourceNode = flowGraph.findNode(connection.sourceNodeId) as? CodeNode
        val targetNode = flowGraph.findNode(connection.targetNodeId) as? CodeNode

        if (sourceNode == null || targetNode == null) {
            return CodeBlock.builder()
                .addStatement("// Warning: Could not resolve connection ${connection.id}")
                .build()
        }

        // Find the port names
        val sourcePort = sourceNode.outputPorts.find { it.id == connection.sourcePortId }
        val targetPort = targetNode.inputPorts.find { it.id == connection.targetPortId }

        val sourcePortName = sourcePort?.name?.camelCase() ?: "output"
        val targetPortName = targetPort?.name?.camelCase() ?: "input"

        return CodeBlock.builder()
            .addStatement("// Connection: ${sourceNode.name}.$sourcePortName -> ${targetNode.name}.$targetPortName")
            .beginControlFlow("scope.launch")
            .beginControlFlow("${sourceNode.name.camelCase()}.${sourcePortName}Output.collect { data ->")
            .addStatement("${targetNode.name.camelCase()}.${targetPortName}Input.emit(data)")
            .endControlFlow()
            .endControlFlow()
            .add("\n")
            .build()
    }

    /**
     * Generates a standalone channel bridge function.
     *
     * @param connection The connection to generate a bridge for
     * @param flowGraph The containing flow graph
     * @return FunSpec for the channel bridge
     */
    fun generateChannelBridge(connection: Connection, flowGraph: FlowGraph): FunSpec {
        val sourceNode = flowGraph.findNode(connection.sourceNodeId) as? CodeNode
        val targetNode = flowGraph.findNode(connection.targetNodeId) as? CodeNode

        val bridgeName = "bridge_${sourceNode?.name?.camelCase() ?: "unknown"}_to_${targetNode?.name?.camelCase() ?: "unknown"}"
        val scopeType = ClassName("kotlinx.coroutines", "CoroutineScope")

        return FunSpec.builder(bridgeName)
            .addModifiers(KModifier.PRIVATE, KModifier.SUSPEND)
            .addParameter("scope", scopeType)
            .addKdoc("Bridges data from ${sourceNode?.name} to ${targetNode?.name}\n")
            .addCode(generateSingleConnection(connection, flowGraph))
            .build()
    }
}
