/*
 * FlowGraphFactoryGenerator
 * Generates factory functions that create FlowGraph instances with all nodes, ports, and connections
 * License: Apache 2.0
 */

package io.codenode.kotlincompiler.generator

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import io.codenode.fbpdsl.model.CodeNode
import io.codenode.fbpdsl.model.Connection
import io.codenode.fbpdsl.model.FlowGraph
import io.codenode.fbpdsl.model.Port

/**
 * Generates factory functions that create FlowGraph instances.
 *
 * The generated factory function creates a fully-configured FlowGraph with:
 * - All CodeNodes with their properties
 * - ProcessingLogic instantiation from _useCaseClass configuration
 * - Port definitions for each node
 * - Connection definitions between nodes
 *
 * Example generated code:
 * ```kotlin
 * fun createStopWatchFlowGraph(): FlowGraph {
 *     val timerEmitter = CodeNode(
 *         id = "timer-emitter",
 *         name = "TimerEmitter",
 *         processingLogic = TimerEmitterComponent(),
 *         ...
 *     )
 *     return FlowGraph(
 *         rootNodes = listOf(timerEmitter, displayReceiver),
 *         connections = listOf(...)
 *     )
 * }
 * ```
 */
class FlowGraphFactoryGenerator {

    companion object {
        const val USE_CASE_CLASS_KEY = "_useCaseClass"
    }

    /**
     * Generates a factory function that creates a FlowGraph instance.
     *
     * @param flowGraph The flow graph definition to generate code for
     * @param packageName Target package name for the generated code
     * @return Generated Kotlin code as a string containing the factory function
     */
    fun generateFactoryFunction(flowGraph: FlowGraph, packageName: String): String {
        val funSpec = generateFactoryFunSpec(flowGraph)

        // Build the FileSpec to get properly formatted output
        val fileSpec = FileSpec.builder(packageName, "FlowGraphFactory")
            .addFunction(funSpec)
            .addImport("io.codenode.fbpdsl.model", "FlowGraph", "CodeNode", "CodeNodeType",
                "Node", "Port", "Connection", "ControlConfig")
            .build()

        return fileSpec.toString()
    }

    /**
     * Generates the factory FunSpec using KotlinPoet.
     *
     * @param flowGraph The flow graph to generate a factory function for
     * @return FunSpec for the factory function
     */
    fun generateFactoryFunSpec(flowGraph: FlowGraph): FunSpec {
        val functionName = "create${flowGraph.name.pascalCase()}FlowGraph"
        val flowGraphType = ClassName("io.codenode.fbpdsl.model", "FlowGraph")

        val funBuilder = FunSpec.builder(functionName)
            .returns(flowGraphType)
            .addKdoc(generateFunctionKDoc(flowGraph))

        // Generate code body
        funBuilder.addCode(generateFunctionBody(flowGraph))

        return funBuilder.build()
    }

    /**
     * Generates KDoc for the factory function.
     */
    private fun generateFunctionKDoc(flowGraph: FlowGraph): CodeBlock {
        return CodeBlock.builder()
            .add("Creates a ${flowGraph.name} FlowGraph with all nodes, ports, connections,\n")
            .add("and ProcessingLogic implementations.\n")
            .add("\n")
            .add("Version: ${flowGraph.version}\n")
            .apply {
                flowGraph.description?.let { add("Description: $it\n") }
            }
            .add("\n")
            .add("@return Fully configured FlowGraph ready for execution\n")
            .add("@generated by CodeNodeIO FlowGraphFactoryGenerator\n")
            .build()
    }

    /**
     * Generates the body of the factory function.
     */
    private fun generateFunctionBody(flowGraph: FlowGraph): CodeBlock {
        val codeBuilder = CodeBlock.builder()

        // Get all CodeNodes
        val codeNodes = flowGraph.getAllCodeNodes()

        // Generate node variable declarations
        codeNodes.forEach { node ->
            codeBuilder.add(generateCodeNodeDeclaration(node))
            codeBuilder.add("\n")
        }

        // Generate connections list
        codeBuilder.add(generateConnectionsList(flowGraph.connections))
        codeBuilder.add("\n")

        // Generate the FlowGraph return statement
        codeBuilder.add(generateFlowGraphReturn(flowGraph, codeNodes))

        return codeBuilder.build()
    }

    /**
     * Generates a CodeNode variable declaration.
     */
    private fun generateCodeNodeDeclaration(node: CodeNode): CodeBlock {
        val varName = node.name.camelCase()
        val codeBuilder = CodeBlock.builder()

        codeBuilder.addStatement("val $varName = CodeNode(")
        codeBuilder.indent()

        // ID
        codeBuilder.addStatement("id = %S,", node.id)

        // Name
        codeBuilder.addStatement("name = %S,", node.name)

        // CodeNodeType
        codeBuilder.addStatement("codeNodeType = CodeNodeType.${node.codeNodeType.name},")

        // Position
        codeBuilder.addStatement("position = Node.Position(${node.position.x}, ${node.position.y}),")

        // Input Ports
        codeBuilder.add(generatePortsList("inputPorts", node.inputPorts))

        // Output Ports
        codeBuilder.add(generatePortsList("outputPorts", node.outputPorts))

        // Configuration
        codeBuilder.add(generateConfigurationMap(node.configuration))

        // ProcessingLogic
        val processingLogicClass = extractProcessingLogicClassName(node.configuration)
        if (processingLogicClass != null) {
            codeBuilder.addStatement("processingLogic = $processingLogicClass()")
        } else {
            codeBuilder.addStatement("processingLogic = null")
        }

        codeBuilder.unindent()
        codeBuilder.addStatement(")")

        return codeBuilder.build()
    }

    /**
     * Generates a list of ports (inputPorts or outputPorts).
     */
    private fun generatePortsList(propertyName: String, ports: List<Port<*>>): CodeBlock {
        val codeBuilder = CodeBlock.builder()

        if (ports.isEmpty()) {
            codeBuilder.addStatement("$propertyName = emptyList(),")
        } else {
            codeBuilder.addStatement("$propertyName = listOf(")
            codeBuilder.indent()

            ports.forEachIndexed { index, port ->
                val comma = if (index < ports.size - 1) "," else ""
                codeBuilder.addStatement("Port(")
                codeBuilder.indent()
                codeBuilder.addStatement("id = %S,", port.id)
                codeBuilder.addStatement("name = %S,", port.name)
                codeBuilder.addStatement("direction = Port.Direction.${port.direction.name},")
                codeBuilder.addStatement("dataType = ${port.dataType.simpleName ?: "Any"}::class,")
                codeBuilder.addStatement("owningNodeId = %S", port.owningNodeId)
                codeBuilder.unindent()
                codeBuilder.addStatement(")$comma")
            }

            codeBuilder.unindent()
            codeBuilder.addStatement("),")
        }

        return codeBuilder.build()
    }

    /**
     * Generates the configuration map.
     */
    private fun generateConfigurationMap(configuration: Map<String, String>): CodeBlock {
        val codeBuilder = CodeBlock.builder()

        if (configuration.isEmpty()) {
            codeBuilder.addStatement("configuration = emptyMap(),")
        } else {
            codeBuilder.addStatement("configuration = mapOf(")
            codeBuilder.indent()

            configuration.entries.forEachIndexed { index, (key, value) ->
                val comma = if (index < configuration.size - 1) "," else ""
                codeBuilder.addStatement("%S to %S$comma", key, value)
            }

            codeBuilder.unindent()
            codeBuilder.addStatement("),")
        }

        return codeBuilder.build()
    }

    /**
     * Extracts the ProcessingLogic class name from the _useCaseClass configuration.
     *
     * @param configuration The node's configuration map
     * @return The class name extracted from the file path, or null if not configured
     */
    fun extractProcessingLogicClassName(configuration: Map<String, String>): String? {
        val useCasePath = configuration[USE_CASE_CLASS_KEY] ?: return null
        if (useCasePath.isBlank()) return null

        // Extract the file name from the path
        val fileName = useCasePath.substringAfterLast("/")

        // Remove the .kt extension to get the class name
        return if (fileName.endsWith(".kt")) {
            fileName.removeSuffix(".kt")
        } else {
            fileName
        }
    }

    /**
     * Collects all ProcessingLogic class names from the FlowGraph.
     *
     * Scans all CodeNodes for _useCaseClass configuration and extracts class names.
     *
     * @param flowGraph The flow graph to scan
     * @return List of ProcessingLogic class names (without duplicates)
     */
    fun collectProcessingLogicClassNames(flowGraph: FlowGraph): List<String> {
        return flowGraph.getAllCodeNodes()
            .mapNotNull { node -> extractProcessingLogicClassName(node.configuration) }
            .distinct()
    }

    /**
     * Generates import statements for ProcessingLogic classes.
     *
     * Converts _useCaseClass file paths to import statements. The import package
     * is derived from the file path structure, assuming standard Kotlin project layout.
     *
     * For example:
     * - `demos/stopwatch/TimerEmitterComponent.kt` â†’ `import demos.stopwatch.TimerEmitterComponent`
     *
     * @param flowGraph The flow graph containing nodes with ProcessingLogic configurations
     * @param defaultPackage The default package to use when path doesn't indicate a package
     * @return List of import statement strings
     */
    fun generateProcessingLogicImports(
        flowGraph: FlowGraph,
        defaultPackage: String = "io.codenode.generated"
    ): List<String> {
        return flowGraph.getAllCodeNodes()
            .mapNotNull { node ->
                val useCasePath = node.configuration[USE_CASE_CLASS_KEY] ?: return@mapNotNull null
                if (useCasePath.isBlank()) return@mapNotNull null

                deriveImportFromPath(useCasePath, defaultPackage)
            }
            .distinct()
    }

    /**
     * Derives a full import statement from a file path.
     *
     * Converts a file path like `demos/stopwatch/TimerEmitterComponent.kt` to
     * a package import like `demos.stopwatch.TimerEmitterComponent`.
     *
     * @param filePath The file path from _useCaseClass configuration
     * @param defaultPackage Fallback package when path is just a filename
     * @return Full import string (e.g., "demos.stopwatch.TimerEmitterComponent")
     */
    fun deriveImportFromPath(filePath: String, defaultPackage: String): String {
        // Remove .kt extension
        val pathWithoutExtension = filePath.removeSuffix(".kt")

        // Check if path has directory components
        val hasDirectory = pathWithoutExtension.contains("/")

        return if (hasDirectory) {
            // Convert path separators to package separators
            pathWithoutExtension.replace("/", ".")
        } else {
            // Just a filename, use default package
            "$defaultPackage.$pathWithoutExtension"
        }
    }

    /**
     * Generates the factory function as a raw Kotlin code string for embedding.
     *
     * This version is suitable for appending to an existing generated file
     * without FileSpec wrapper.
     *
     * @param flowGraph The flow graph to generate a factory function for
     * @return Raw Kotlin function code as a string
     */
    fun generateFactoryFunctionRaw(flowGraph: FlowGraph): String {
        val funSpec = generateFactoryFunSpec(flowGraph)
        return funSpec.toString()
    }

    /**
     * Generates the connections list.
     */
    private fun generateConnectionsList(connections: List<Connection>): CodeBlock {
        val codeBuilder = CodeBlock.builder()

        if (connections.isEmpty()) {
            codeBuilder.addStatement("val connections = emptyList<Connection>()")
        } else {
            codeBuilder.addStatement("val connections = listOf(")
            codeBuilder.indent()

            connections.forEachIndexed { index, connection ->
                val comma = if (index < connections.size - 1) "," else ""
                codeBuilder.addStatement("Connection(")
                codeBuilder.indent()
                codeBuilder.addStatement("id = %S,", connection.id)
                codeBuilder.addStatement("sourceNodeId = %S,", connection.sourceNodeId)
                codeBuilder.addStatement("sourcePortId = %S,", connection.sourcePortId)
                codeBuilder.addStatement("targetNodeId = %S,", connection.targetNodeId)
                codeBuilder.addStatement("targetPortId = %S,", connection.targetPortId)
                codeBuilder.addStatement("channelCapacity = ${connection.channelCapacity}")
                codeBuilder.unindent()
                codeBuilder.addStatement(")$comma")
            }

            codeBuilder.unindent()
            codeBuilder.addStatement(")")
        }

        return codeBuilder.build()
    }

    /**
     * Generates the FlowGraph return statement.
     */
    private fun generateFlowGraphReturn(flowGraph: FlowGraph, codeNodes: List<CodeNode>): CodeBlock {
        val codeBuilder = CodeBlock.builder()

        codeBuilder.addStatement("return FlowGraph(")
        codeBuilder.indent()

        // ID
        codeBuilder.addStatement("id = %S,", flowGraph.id)

        // Name
        codeBuilder.addStatement("name = %S,", flowGraph.name)

        // Version
        codeBuilder.addStatement("version = %S,", flowGraph.version)

        // Description
        if (flowGraph.description != null) {
            codeBuilder.addStatement("description = %S,", flowGraph.description)
        } else {
            codeBuilder.addStatement("description = null,")
        }

        // Root nodes
        if (codeNodes.isEmpty()) {
            codeBuilder.addStatement("rootNodes = emptyList(),")
        } else {
            val nodeVarNames = codeNodes.joinToString(", ") { it.name.camelCase() }
            codeBuilder.addStatement("rootNodes = listOf($nodeVarNames),")
        }

        // Connections
        codeBuilder.addStatement("connections = connections,")

        // Target platforms
        if (flowGraph.targetPlatforms.isEmpty()) {
            codeBuilder.addStatement("targetPlatforms = emptyList()")
        } else {
            val platforms = flowGraph.targetPlatforms.joinToString(", ") {
                "FlowGraph.TargetPlatform.${it.name}"
            }
            codeBuilder.addStatement("targetPlatforms = listOf($platforms)")
        }

        codeBuilder.unindent()
        codeBuilder.addStatement(")")

        return codeBuilder.build()
    }
}
