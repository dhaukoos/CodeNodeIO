/*
 * RuntimeFlowGenerator
 * Generates {Name}Flow.kt from FlowGraph
 * License: Apache 2.0
 */

package io.codenode.kotlincompiler.generator

import io.codenode.fbpdsl.model.CodeNode
import io.codenode.fbpdsl.model.FlowGraph

/**
 * Generates a {Name}Flow.kt file that directly creates runtime instances
 * via CodeNodeFactory, wires connections, and owns MutableStateFlow
 * properties for sink input ports.
 *
 * The generated Flow class:
 * - Imports tick vals from the usecases.logicmethods package
 * - Creates runtime instances using CodeNodeFactory.create*() methods
 * - Wraps sink consume blocks to update MutableStateFlow + call user tick
 * - Provides start(scope)/stop()/reset()/wireConnections() methods
 */
class RuntimeFlowGenerator {

    private val observableStateResolver = ObservableStateResolver()
    private val connectionWiringResolver = ConnectionWiringResolver()
    private val runtimeTypeResolver = RuntimeTypeResolver()

    /**
     * Generates the {Name}Flow.kt file content from a FlowGraph.
     *
     * @param flowGraph The flow graph to generate from
     * @param generatedPackage The package name for the generated file
     * @param usecasesPackage The package name for user-written tick stubs
     * @return Generated Kotlin source code
     */
    fun generate(flowGraph: FlowGraph, generatedPackage: String, usecasesPackage: String): String {
        val flowName = flowGraph.name.pascalCase()
        val codeNodes = flowGraph.getAllCodeNodes()
        val observableProps = observableStateResolver.getObservableStateProperties(flowGraph)
        val wiringStatements = connectionWiringResolver.getWiringStatements(flowGraph)

        return buildString {
            generateHeader(flowGraph, flowName)
            generatePackage(generatedPackage)
            generateImports(codeNodes, usecasesPackage, observableProps.isNotEmpty())
            appendLine()
            generateKDoc(flowGraph, flowName)
            appendLine("class ${flowName}Flow {")
            appendLine()

            if (observableProps.isNotEmpty()) {
                generateObservableState(observableProps)
            }

            generateRuntimeInstances(codeNodes, observableProps, flowGraph)
            generateStartMethod(codeNodes)
            generateStopMethod(codeNodes)
            generateResetMethod(observableProps)
            generateWireConnectionsMethod(wiringStatements)

            appendLine("}")
            appendLine()
        }
    }

    private fun StringBuilder.generateHeader(flowGraph: FlowGraph, flowName: String) {
        appendLine("/*")
        appendLine(" * $flowName Flow")
        appendLine(" * Generated by CodeNodeIO RuntimeFlowGenerator")
        appendLine(" * License: Apache 2.0")
        appendLine(" */")
        appendLine()
    }

    private fun StringBuilder.generatePackage(generatedPackage: String) {
        appendLine("package $generatedPackage")
        appendLine()
    }

    private fun StringBuilder.generateImports(
        codeNodes: List<CodeNode>,
        usecasesPackage: String,
        hasObservableState: Boolean
    ) {
        // Tick function imports from user stubs
        codeNodes.forEach { node ->
            appendLine("import $usecasesPackage.logicmethods.${node.name.camelCase()}Tick")
        }
        appendLine()

        // Framework imports
        appendLine("import io.codenode.fbpdsl.model.CodeNodeFactory")
        appendLine("import kotlinx.coroutines.CoroutineScope")
        if (hasObservableState) {
            appendLine("import kotlinx.coroutines.flow.MutableStateFlow")
            appendLine("import kotlinx.coroutines.flow.StateFlow")
            appendLine("import kotlinx.coroutines.flow.asStateFlow")
        }
    }

    private fun StringBuilder.generateKDoc(flowGraph: FlowGraph, flowName: String) {
        val codeNodes = flowGraph.getAllCodeNodes()
        appendLine("/**")
        appendLine(" * Flow orchestrator for: ${flowGraph.name}")
        appendLine(" *")
        appendLine(" * Version: ${flowGraph.version}")
        flowGraph.description?.let { desc ->
            appendLine(" * Description: $desc")
        }
        appendLine(" *")
        appendLine(" * Nodes: ${codeNodes.size}")
        appendLine(" * Connections: ${flowGraph.connections.size}")
        appendLine(" *")
        appendLine(" * @generated by CodeNodeIO RuntimeFlowGenerator")
        appendLine(" */")
    }

    private fun StringBuilder.generateObservableState(observableProps: List<ObservableProperty>) {
        appendLine("    // Observable state for sink ports")
        observableProps.forEach { prop ->
            appendLine("    private val _${prop.name} = MutableStateFlow(${prop.defaultValue})")
            appendLine("    val ${prop.name}Flow: StateFlow<${prop.typeName}> = _${prop.name}.asStateFlow()")
        }
        appendLine()
    }

    private fun StringBuilder.generateRuntimeInstances(
        codeNodes: List<CodeNode>,
        observableProps: List<ObservableProperty>,
        flowGraph: FlowGraph
    ) {
        appendLine("    // Runtime instances")
        codeNodes.forEach { node ->
            val varName = node.name.camelCase()
            val factoryMethod = runtimeTypeResolver.getFactoryMethodName(node)
            val typeParams = getFactoryTypeParams(node)
            val tickParamName = runtimeTypeResolver.getTickParamName(node)
            val isSink = node.inputPorts.isNotEmpty() && node.outputPorts.isEmpty()
            val isGenerator = node.inputPorts.isEmpty() && node.outputPorts.isNotEmpty()

            appendLine("    internal val $varName = CodeNodeFactory.$factoryMethod<$typeParams>(")
            appendLine("        name = \"${node.name}\",")

            if (isGenerator) {
                appendLine("        tickIntervalMs = 1000L,")
                appendLine("        $tickParamName = ${varName}Tick")
            } else if (isSink) {
                generateSinkConsumeBlock(node, varName, tickParamName, observableProps, flowGraph)
            } else {
                appendLine("        $tickParamName = ${varName}Tick")
            }

            appendLine("    )")
            appendLine()
        }
    }

    private fun StringBuilder.generateSinkConsumeBlock(
        node: CodeNode,
        varName: String,
        tickParamName: String,
        observableProps: List<ObservableProperty>,
        flowGraph: FlowGraph
    ) {
        val portNames = node.inputPorts.map { it.name.camelCase() }
        val portNamesStr = portNames.joinToString(", ")

        // Find observable properties for this sink's ports
        val sinkProps = node.inputPorts.map { port ->
            observableProps.find { prop ->
                prop.sourceNodeName == node.name && prop.sourcePortName == port.name
            }
        }

        appendLine("        $tickParamName = { $portNamesStr ->")
        sinkProps.forEachIndexed { index, prop ->
            if (prop != null) {
                appendLine("            _${prop.name}.value = ${portNames[index]}")
            }
        }
        appendLine("            ${varName}Tick($portNamesStr)")
        append("        }")
    }

    private fun StringBuilder.generateStartMethod(codeNodes: List<CodeNode>) {
        appendLine("    /**")
        appendLine("     * Starts the flow with the given coroutine scope.")
        appendLine("     */")
        appendLine("    suspend fun start(scope: CoroutineScope) {")

        // Start generators first
        val generators = codeNodes.filter { it.inputPorts.isEmpty() && it.outputPorts.isNotEmpty() }
        generators.forEach { node ->
            appendLine("        ${node.name.camelCase()}.start(scope)")
        }

        // Wire connections
        appendLine("        wireConnections()")

        // Start non-generators
        val nonGenerators = codeNodes.filter { !(it.inputPorts.isEmpty() && it.outputPorts.isNotEmpty()) }
        nonGenerators.forEach { node ->
            appendLine("        ${node.name.camelCase()}.start(scope)")
        }

        appendLine("    }")
        appendLine()
    }

    private fun StringBuilder.generateStopMethod(codeNodes: List<CodeNode>) {
        appendLine("    /**")
        appendLine("     * Stops all runtime instances.")
        appendLine("     */")
        appendLine("    fun stop() {")
        codeNodes.forEach { node ->
            appendLine("        ${node.name.camelCase()}.stop()")
        }
        appendLine("    }")
        appendLine()
    }

    private fun StringBuilder.generateResetMethod(observableProps: List<ObservableProperty>) {
        appendLine("    /**")
        appendLine("     * Resets all observable state.")
        appendLine("     */")
        appendLine("    fun reset() {")
        observableProps.forEach { prop ->
            appendLine("        _${prop.name}.value = ${prop.defaultValue}")
        }
        appendLine("    }")
        appendLine()
    }

    /**
     * Gets factory-appropriate type parameters for a node.
     * Filters use a single type param; all others use combined input+output types.
     */
    private fun getFactoryTypeParams(node: CodeNode): String {
        val inputs = node.inputPorts.size
        val outputs = node.outputPorts.size
        if (inputs == 1 && outputs == 1) {
            val inType = node.inputPorts[0].dataType.simpleName ?: "Any"
            val outType = node.outputPorts[0].dataType.simpleName ?: "Any"
            if (inType == outType) return inType
        }
        return runtimeTypeResolver.getTypeParams(node)
    }

    private fun StringBuilder.generateWireConnectionsMethod(wiringStatements: List<WiringStatement>) {
        appendLine("    /**")
        appendLine("     * Wires connections between runtime instances.")
        appendLine("     */")
        appendLine("    private fun wireConnections() {")
        wiringStatements.forEach { stmt ->
            appendLine("        ${stmt.targetVarName}.${stmt.targetChannelProp} = ${stmt.sourceVarName}.${stmt.sourceChannelProp}")
        }
        appendLine("    }")
    }
}
