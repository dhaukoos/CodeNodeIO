/*
 * RuntimeControllerGenerator
 * Generates {Name}Controller.kt from FlowGraph
 * License: Apache 2.0
 */

package io.codenode.kotlincompiler.generator

import io.codenode.fbpdsl.model.CodeNode
import io.codenode.fbpdsl.model.FlowGraph

/**
 * Generates a {Name}Controller.kt file that wraps the Flow with execution
 * control and exposes observable state as StateFlow properties.
 *
 * The generated Controller class:
 * - Takes FlowGraph as constructor param
 * - Creates RuntimeRegistry, RootControlNode, and {Name}Flow instances
 * - Exposes StateFlow properties for executionState and all observable state
 * - Provides start/stop/pause/resume/reset/getStatus/setNodeState/setNodeConfig
 * - Includes bindToLifecycle for lifecycle-aware execution
 */
class RuntimeControllerGenerator {

    private val observableStateResolver = ObservableStateResolver()

    /**
     * Generates the {Name}Controller.kt file content from a FlowGraph.
     *
     * @param flowGraph The flow graph to generate from
     * @param generatedPackage The package name for the generated file
     * @param usecasesPackage The package name for user-written tick stubs (unused by Controller)
     * @return Generated Kotlin source code
     */
    fun generate(flowGraph: FlowGraph, generatedPackage: String, usecasesPackage: String): String {
        val flowName = flowGraph.name.pascalCase()
        val codeNodes = flowGraph.getAllCodeNodes()
        val observableProps = observableStateResolver.getObservableStateProperties(flowGraph)

        return buildString {
            generateHeader(flowName)
            generatePackage(generatedPackage)
            generateImports()
            appendLine()
            generateKDoc(flowName)
            appendLine("class ${flowName}Controller(")
            appendLine("    private var flowGraph: FlowGraph")
            appendLine(") {")
            appendLine()
            generateFields(flowName)
            generateObservableState(observableProps)
            generateExecutionState()
            generateStartMethod(flowName, codeNodes)
            generatePauseMethod(flowName)
            generateResumeMethod(flowName)
            generateStopMethod(flowName)
            generateResetMethod(codeNodes)
            generateGetStatusMethod()
            generateSetNodeStateMethod(flowName)
            generateSetNodeConfigMethod(flowName)
            generateBindToLifecycleMethod()
            generateCurrentFlowGraphGetter()
            appendLine("}")
            appendLine()
        }
    }

    private fun StringBuilder.generateHeader(flowName: String) {
        appendLine("/*")
        appendLine(" * $flowName Controller")
        appendLine(" * Generated by CodeNodeIO RuntimeControllerGenerator")
        appendLine(" * License: Apache 2.0")
        appendLine(" */")
        appendLine()
    }

    private fun StringBuilder.generatePackage(generatedPackage: String) {
        appendLine("package $generatedPackage")
        appendLine()
    }

    private fun StringBuilder.generateImports() {
        appendLine("import io.codenode.fbpdsl.model.RootControlNode")
        appendLine("import io.codenode.fbpdsl.model.FlowGraph")
        appendLine("import io.codenode.fbpdsl.model.FlowExecutionStatus")
        appendLine("import io.codenode.fbpdsl.model.ExecutionState")
        appendLine("import io.codenode.fbpdsl.model.ControlConfig")
        appendLine("import io.codenode.fbpdsl.runtime.RuntimeRegistry")
        appendLine("import androidx.lifecycle.Lifecycle")
        appendLine("import androidx.lifecycle.LifecycleEventObserver")
        appendLine("import androidx.lifecycle.LifecycleOwner")
        appendLine("import kotlinx.coroutines.CoroutineScope")
        appendLine("import kotlinx.coroutines.Dispatchers")
        appendLine("import kotlinx.coroutines.SupervisorJob")
        appendLine("import kotlinx.coroutines.cancel")
        appendLine("import kotlinx.coroutines.flow.MutableStateFlow")
        appendLine("import kotlinx.coroutines.flow.StateFlow")
        appendLine("import kotlinx.coroutines.flow.asStateFlow")
        appendLine("import kotlinx.coroutines.launch")
    }

    private fun StringBuilder.generateKDoc(flowName: String) {
        appendLine("/**")
        appendLine(" * Controller for $flowName flow execution.")
        appendLine(" *")
        appendLine(" * Provides unified control operations for starting, pausing,")
        appendLine(" * stopping, and monitoring the flow execution.")
        appendLine(" *")
        appendLine(" * @param flowGraph The FlowGraph instance to control")
        appendLine(" * @generated by CodeNodeIO RuntimeControllerGenerator")
        appendLine(" */")
    }

    private fun StringBuilder.generateFields(flowName: String) {
        appendLine("    private val registry = RuntimeRegistry()")
        appendLine()
        appendLine("    private var controller: RootControlNode = RootControlNode.createFor(")
        appendLine("        flowGraph = flowGraph,")
        appendLine("        name = \"${flowName}Controller\",")
        appendLine("        registry = registry")
        appendLine("    )")
        appendLine()
        appendLine("    private val flow = ${flowName}Flow()")
        appendLine()
        appendLine("    private var flowScope: CoroutineScope? = null")
        appendLine()
        appendLine("    private var wasRunningBeforePause: Boolean = false")
        appendLine()
    }

    private fun StringBuilder.generateObservableState(observableProps: List<ObservableProperty>) {
        if (observableProps.isEmpty()) return

        observableProps.forEach { prop ->
            appendLine("    val ${prop.name}: StateFlow<${prop.typeName}> = flow.${prop.name}Flow")
        }
        appendLine()
    }

    private fun StringBuilder.generateExecutionState() {
        appendLine("    private val _executionState = MutableStateFlow(ExecutionState.IDLE)")
        appendLine("    val executionState: StateFlow<ExecutionState> = _executionState.asStateFlow()")
        appendLine()
    }

    private fun StringBuilder.generateStartMethod(flowName: String, codeNodes: List<CodeNode>) {
        appendLine("    fun start(): FlowGraph {")
        appendLine("        flowGraph = controller.startAll()")
        appendLine("        controller = RootControlNode.createFor(flowGraph, \"${flowName}Controller\", registry)")
        appendLine("        _executionState.value = ExecutionState.RUNNING")
        appendLine()
        appendLine("        flowScope?.cancel()")
        appendLine("        val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)")
        appendLine("        flowScope = scope")
        appendLine()

        // Wire registry to all runtime instances
        codeNodes.forEach { node ->
            appendLine("        flow.${node.name.camelCase()}.registry = registry")
        }
        appendLine()

        // Set executionState = RUNNING for generators only
        val generators = codeNodes.filter { it.inputPorts.isEmpty() && it.outputPorts.isNotEmpty() }
        generators.forEach { node ->
            appendLine("        flow.${node.name.camelCase()}.executionState = ExecutionState.RUNNING")
        }

        appendLine("        scope.launch {")
        appendLine("            flow.start(scope)")
        appendLine("        }")
        appendLine()
        appendLine("        return flowGraph")
        appendLine("    }")
        appendLine()
    }

    private fun StringBuilder.generatePauseMethod(flowName: String) {
        appendLine("    fun pause(): FlowGraph {")
        appendLine("        flowGraph = controller.pauseAll()")
        appendLine("        controller = RootControlNode.createFor(flowGraph, \"${flowName}Controller\", registry)")
        appendLine("        _executionState.value = ExecutionState.PAUSED")
        appendLine("        return flowGraph")
        appendLine("    }")
        appendLine()
    }

    private fun StringBuilder.generateResumeMethod(flowName: String) {
        appendLine("    fun resume(): FlowGraph {")
        appendLine("        flowGraph = controller.resumeAll()")
        appendLine("        controller = RootControlNode.createFor(flowGraph, \"${flowName}Controller\", registry)")
        appendLine("        _executionState.value = ExecutionState.RUNNING")
        appendLine("        return flowGraph")
        appendLine("    }")
        appendLine()
    }

    private fun StringBuilder.generateStopMethod(flowName: String) {
        appendLine("    fun stop(): FlowGraph {")
        appendLine("        flowGraph = controller.stopAll()")
        appendLine("        controller = RootControlNode.createFor(flowGraph, \"${flowName}Controller\", registry)")
        appendLine("        _executionState.value = ExecutionState.IDLE")
        appendLine()
        appendLine("        flow.stop()")
        appendLine("        flowScope?.cancel()")
        appendLine("        flowScope = null")
        appendLine()
        appendLine("        return flowGraph")
        appendLine("    }")
        appendLine()
    }

    private fun StringBuilder.generateResetMethod(codeNodes: List<CodeNode>) {
        appendLine("    fun reset(): FlowGraph {")
        appendLine("        wasRunningBeforePause = false")
        codeNodes.forEach { node ->
            appendLine("        flow.${node.name.camelCase()}.reset()")
        }
        appendLine("        flow.reset()")
        appendLine("        return stop()")
        appendLine("    }")
        appendLine()
    }

    private fun StringBuilder.generateGetStatusMethod() {
        appendLine("    fun getStatus(): FlowExecutionStatus {")
        appendLine("        return controller.getStatus()")
        appendLine("    }")
        appendLine()
    }

    private fun StringBuilder.generateSetNodeStateMethod(flowName: String) {
        appendLine("    fun setNodeState(nodeId: String, state: ExecutionState): FlowGraph {")
        appendLine("        flowGraph = controller.setNodeState(nodeId, state)")
        appendLine("        controller = RootControlNode.createFor(flowGraph, \"${flowName}Controller\")")
        appendLine("        return flowGraph")
        appendLine("    }")
        appendLine()
    }

    private fun StringBuilder.generateSetNodeConfigMethod(flowName: String) {
        appendLine("    fun setNodeConfig(nodeId: String, config: ControlConfig): FlowGraph {")
        appendLine("        flowGraph = controller.setNodeConfig(nodeId, config)")
        appendLine("        controller = RootControlNode.createFor(flowGraph, \"${flowName}Controller\")")
        appendLine("        return flowGraph")
        appendLine("    }")
        appendLine()
    }

    private fun StringBuilder.generateBindToLifecycleMethod() {
        appendLine("    fun bindToLifecycle(lifecycle: Lifecycle) {")
        appendLine("        lifecycle.addObserver(object : LifecycleEventObserver {")
        appendLine("            override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) {")
        appendLine("                when (event) {")
        appendLine("                    Lifecycle.Event.ON_START -> {")
        appendLine("                        if (wasRunningBeforePause) {")
        appendLine("                            start()")
        appendLine("                            wasRunningBeforePause = false")
        appendLine("                        }")
        appendLine("                    }")
        appendLine("                    Lifecycle.Event.ON_STOP -> {")
        appendLine("                        val status = getStatus()")
        appendLine("                        wasRunningBeforePause = status.overallState == ExecutionState.RUNNING")
        appendLine("                        if (wasRunningBeforePause) {")
        appendLine("                            pause()")
        appendLine("                        }")
        appendLine("                    }")
        appendLine("                    Lifecycle.Event.ON_DESTROY -> {")
        appendLine("                        stop()")
        appendLine("                    }")
        appendLine("                    else -> { /* no-op */ }")
        appendLine("                }")
        appendLine("            }")
        appendLine("        })")
        appendLine("    }")
        appendLine()
    }

    private fun StringBuilder.generateCurrentFlowGraphGetter() {
        appendLine("    val currentFlowGraph: FlowGraph")
        appendLine("        get() = flowGraph")
    }
}
