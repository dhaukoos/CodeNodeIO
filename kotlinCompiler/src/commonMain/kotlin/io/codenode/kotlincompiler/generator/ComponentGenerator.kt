/*
 * Component Generator
 * Generates KMP component classes from CodeNodes using KotlinPoet
 * License: Apache 2.0
 */

package io.codenode.kotlincompiler.generator

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import io.codenode.fbpdsl.model.CodeNode
import io.codenode.fbpdsl.model.CodeNodeType
import io.codenode.fbpdsl.model.Port
import io.codenode.kotlincompiler.templates.NodeTemplate
import io.codenode.kotlincompiler.templates.NodeTemplateRegistry

/**
 * Generates Kotlin component classes from CodeNode definitions.
 *
 * Each CodeNode is transformed into a class with:
 * - Properties for input channels
 * - Properties for output channels
 * - A process() suspend function for the node's business logic
 * - Configuration properties from the node's configuration map
 *
 * Generated code uses kotlinx.coroutines for async processing.
 */
class ComponentGenerator {

    companion object {
        const val GENERATED_PACKAGE = "io.codenode.generated"
        // Use the base package for backward compatibility with existing tests
        const val COMPONENTS_PACKAGE = GENERATED_PACKAGE
    }

    private val templateRegistry = NodeTemplateRegistry()

    /**
     * Generates a component class from a CodeNode.
     *
     * @param node The CodeNode to generate a component for
     * @return FileSpec containing the generated Kotlin file
     */
    fun generateComponent(node: CodeNode): FileSpec {
        val className = node.name.pascalCase()
        val classNameObj = ClassName(COMPONENTS_PACKAGE, className)

        // Check if we have a template for this node type
        val template = templateRegistry.getTemplate(node.codeNodeType)

        val componentClass = if (template != null) {
            generateFromTemplate(node, classNameObj, template)
        } else {
            generateDefaultComponent(node, classNameObj)
        }

        return FileSpec.builder(COMPONENTS_PACKAGE, className)
            .addType(componentClass)
            .addImport("kotlinx.coroutines.channels", "Channel", "SendChannel", "ReceiveChannel")
            .addImport("kotlinx.coroutines.channels", "ClosedSendChannelException", "ClosedReceiveChannelException")
            .addImport("kotlinx.coroutines", "CoroutineScope", "launch")
            .build()
    }

    /**
     * Generates a component using a template for the node type.
     */
    private fun generateFromTemplate(
        node: CodeNode,
        className: ClassName,
        template: NodeTemplate
    ): TypeSpec {
        return template.generate(node, className)
    }

    /**
     * Generates a default component when no template is available.
     */
    private fun generateDefaultComponent(node: CodeNode, className: ClassName): TypeSpec {
        val classBuilder = TypeSpec.classBuilder(className)
            .addKdoc(generateKDoc(node))

        // Add input channel properties
        node.inputPorts.forEach { port ->
            classBuilder.addProperty(generateInputChannelProperty(port))
        }

        // Add output channel properties
        node.outputPorts.forEach { port ->
            classBuilder.addProperty(generateOutputChannelProperty(port))
        }

        // Add configuration properties from node.configuration
        node.configuration.forEach { (key, value) ->
            classBuilder.addProperty(
                PropertySpec.builder(key.camelCase(), String::class)
                    .initializer("%S", value)
                    .build()
            )
        }

        // Add the main process function
        classBuilder.addFunction(generateProcessFunction(node))

        // Add start function for coroutine execution
        classBuilder.addFunction(generateStartFunction(node))

        return classBuilder.build()
    }

    /**
     * Generates KDoc documentation for the component.
     */
    private fun generateKDoc(node: CodeNode): CodeBlock {
        return CodeBlock.builder()
            .add("Generated component for node: ${node.name}\n")
            .add("\n")
            .add("Type: ${node.nodeType}\n")
            .apply {
                node.description?.let { add("Description: $it\n") }
            }
            .add("\n")
            .add("@generated by CodeNodeIO KotlinCompiler\n")
            .build()
    }

    /**
     * Generates an input channel property for receiving data.
     * Uses ReceiveChannel for FBP point-to-point semantics with backpressure.
     */
    private fun generateInputChannelProperty(port: Port<*>): PropertySpec {
        val channelType = ClassName("kotlinx.coroutines.channels", "ReceiveChannel")
            .parameterizedBy(ANY)

        return PropertySpec.builder(
            "${port.name.camelCase()}Channel",
            channelType.copy(nullable = true)
        )
            .mutable(true)
            .initializer("null")
            .addKdoc("Input channel for port: ${port.name} (type: ${port.typeName})")
            .build()
    }

    /**
     * Generates an output channel property for emitting data.
     * Uses SendChannel for FBP point-to-point semantics with backpressure.
     */
    private fun generateOutputChannelProperty(port: Port<*>): PropertySpec {
        val channelType = ClassName("kotlinx.coroutines.channels", "SendChannel")
            .parameterizedBy(ANY)

        return PropertySpec.builder(
            "${port.name.camelCase()}Channel",
            channelType.copy(nullable = true)
        )
            .mutable(true)
            .initializer("null")
            .addKdoc("Output channel for port: ${port.name} (type: ${port.typeName})")
            .build()
    }

    /**
     * Generates the main process function that handles input processing.
     */
    private fun generateProcessFunction(node: CodeNode): FunSpec {
        val funBuilder = FunSpec.builder("process")
            .addModifiers(KModifier.SUSPEND)
            .addKdoc("Processes input data and emits to output channels.\n")
            .addKdoc("Override this method to implement custom processing logic.\n")

        // Add parameters for each input port
        node.inputPorts.forEach { port ->
            funBuilder.addParameter(port.name.camelCase(), ANY.copy(nullable = true))
        }

        // Generate return type based on output ports
        when (node.outputPorts.size) {
            0 -> {
                // No outputs - Unit return
                funBuilder.addCode(generateProcessBody(node))
            }
            1 -> {
                // Single output - return the value directly
                funBuilder.returns(ANY.copy(nullable = true))
                funBuilder.addCode(generateProcessBody(node))
            }
            else -> {
                // Multiple outputs - return a map
                val mapType = MAP.parameterizedBy(STRING, ANY.copy(nullable = true))
                funBuilder.returns(mapType)
                funBuilder.addCode(generateProcessBody(node))
            }
        }

        return funBuilder.build()
    }

    /**
     * Generates the body of the process function based on node type.
     */
    private fun generateProcessBody(node: CodeNode): CodeBlock {
        return when (node.codeNodeType) {
            CodeNodeType.TRANSFORMER -> CodeBlock.builder()
                .addStatement("// TODO: Implement transformation logic")
                .addStatement("return ${if (node.inputPorts.isNotEmpty()) node.inputPorts.first().name.camelCase() else "null"}")
                .build()

            CodeNodeType.FILTER -> CodeBlock.builder()
                .addStatement("// TODO: Implement filter predicate")
                .addStatement("return ${if (node.inputPorts.isNotEmpty()) node.inputPorts.first().name.camelCase() else "null"} // Pass through if filter matches")
                .build()

            CodeNodeType.VALIDATOR -> CodeBlock.builder()
                .addStatement("// TODO: Implement validation logic")
                .addStatement("return mapOf(\"valid\" to true, \"data\" to ${if (node.inputPorts.isNotEmpty()) node.inputPorts.first().name.camelCase() else "null"})")
                .build()

            CodeNodeType.SPLITTER -> CodeBlock.builder()
                .addStatement("// TODO: Implement split logic")
                .addStatement("return mapOf(${node.outputPorts.joinToString(", ") { "\"${it.name}\" to null" }})")
                .build()

            CodeNodeType.MERGER -> CodeBlock.builder()
                .addStatement("// TODO: Implement merge logic")
                .addStatement("return listOf(${node.inputPorts.joinToString(", ") { it.name.camelCase() }}).firstOrNull()")
                .build()

            CodeNodeType.GENERATOR -> CodeBlock.builder()
                .addStatement("// TODO: Implement generation logic")
                .addStatement("return null // Generate and return data")
                .build()

            CodeNodeType.SINK -> CodeBlock.builder()
                .addStatement("// TODO: Implement sink logic (logging, persistence, etc.)")
                .build()

            else -> CodeBlock.builder()
                .addStatement("// TODO: Implement custom processing logic")
                .addStatement("return null")
                .build()
        }
    }

    /**
     * Generates the start function that launches the coroutine processing loop.
     * Uses channel iteration (for-in) and handles ClosedReceiveChannelException gracefully.
     */
    private fun generateStartFunction(node: CodeNode): FunSpec {
        val scopeType = ClassName("kotlinx.coroutines", "CoroutineScope")

        return FunSpec.builder("start")
            .addParameter("scope", scopeType)
            .addKdoc("Starts the component's processing loop in the given coroutine scope.\n")
            .addCode(CodeBlock.builder()
                .beginControlFlow("scope.launch")
                .beginControlFlow("try")
                .apply {
                    if (node.inputPorts.isNotEmpty()) {
                        val firstInput = node.inputPorts.first()
                        val channelName = "${firstInput.name.camelCase()}Channel"
                        addStatement("val channel = $channelName ?: return@launch")
                        beginControlFlow("for (input in channel)")
                        addStatement("val result = process(input)")
                        if (node.outputPorts.isNotEmpty()) {
                            val outputChannel = "${node.outputPorts.first().name.camelCase()}Channel"
                            addStatement("$outputChannel?.send(result)")
                        }
                        endControlFlow()
                    } else {
                        addStatement("// Generator node - implement generation loop")
                        addStatement("val result = process()")
                        if (node.outputPorts.isNotEmpty()) {
                            val outputChannel = "${node.outputPorts.first().name.camelCase()}Channel"
                            addStatement("$outputChannel?.send(result)")
                        }
                    }
                }
                .nextControlFlow("catch (e: %T)", ClassName("kotlinx.coroutines.channels", "ClosedReceiveChannelException"))
                .addStatement("// Channel closed - graceful shutdown")
                .nextControlFlow("catch (e: %T)", ClassName("kotlinx.coroutines.channels", "ClosedSendChannelException"))
                .addStatement("// Output channel closed - graceful shutdown")
                .endControlFlow()
                .endControlFlow()
                .build())
            .build()
    }
}
