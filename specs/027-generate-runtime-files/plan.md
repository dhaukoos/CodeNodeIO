# Implementation Plan: Generate Runtime Files from FlowGraph Compilation

**Branch**: `027-generate-runtime-files` | **Date**: 2026-02-20 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/027-generate-runtime-files/spec.md`

## Summary

When a FlowGraph is compiled/saved from the graphEditor, generate 5 runtime files in the `generated` package: `{Name}Flow`, `{Name}Controller`, `{Name}ControllerInterface`, `{Name}ControllerAdapter`, and `{Name}ViewModel`. These files wire FlowGraph nodes into an executable MVVM runtime stack. Observable state is derived from sink node input ports. New generator classes are added to the `kotlinCompiler` module and called from `ModuleSaveService`.

## Technical Context

**Language/Version**: Kotlin 2.1.21 (KMP - Kotlin Multiplatform)
**Primary Dependencies**: kotlinx-coroutines 1.8.0, kotlinx-serialization 1.6.0, Compose Multiplatform 1.7.3, lifecycle-viewmodel-compose 2.8.0
**Storage**: N/A (generates source code files to filesystem)
**Testing**: kotlin.test (commonTest), JVM tests via Gradle
**Target Platform**: KMP (JVM, Android, iOS, Web, WASM)
**Project Type**: Multi-module KMP project (fbpDsl, kotlinCompiler, graphEditor, StopWatch)
**Performance Goals**: Code generation completes in <1s for typical FlowGraphs (<50 nodes)
**Constraints**: Generated code must compile in KMP commonMain; must follow existing generator patterns
**Scale/Scope**: 5 new generator classes in kotlinCompiler, 1 integration point in graphEditor

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Gate | Status | Notes |
|------|--------|-------|
| Licensing (Apache 2.0 only) | PASS | No new dependencies. All generated code is Apache 2.0 |
| Code Quality (readability, maintainability) | PASS | Follows existing generator patterns (FlowKtGenerator, ProcessingLogicStubGenerator) |
| TDD (tests first) | PASS | Unit tests for each generator before integration |
| Type Safety | PASS | Generators produce typed Kotlin code; type resolution from Port.dataType |
| Security | N/A | Code generation, no user input at runtime |
| Documentation | PASS | KDoc on all public generator methods |

**Post-Phase 1 Re-check**: All gates still pass. No new dependencies introduced. Generated code uses only existing fbpDsl and AndroidX Lifecycle APIs already in the project.

## Project Structure

### Documentation (this feature)

```text
specs/027-generate-runtime-files/
├── plan.md              # This file
├── spec.md              # Feature specification
├── research.md          # Phase 0 research output
├── data-model.md        # Phase 1 data model
├── quickstart.md        # Integration scenarios
├── checklists/
│   └── requirements.md  # Spec quality checklist
└── tasks.md             # Task breakdown (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
kotlinCompiler/
├── src/commonMain/kotlin/io/codenode/kotlincompiler/generator/
│   ├── RuntimeFlowGenerator.kt              # NEW: Generates {Name}Flow.kt
│   ├── RuntimeControllerGenerator.kt        # NEW: Generates {Name}Controller.kt
│   ├── RuntimeControllerInterfaceGenerator.kt  # NEW: Generates {Name}ControllerInterface.kt
│   ├── RuntimeControllerAdapterGenerator.kt # NEW: Generates {Name}ControllerAdapter.kt
│   ├── RuntimeViewModelGenerator.kt         # NEW: Generates {Name}ViewModel.kt
│   ├── FlowKtGenerator.kt                  # EXISTING: reference pattern
│   ├── ProcessingLogicStubGenerator.kt      # EXISTING: reference pattern
│   └── KotlinCodeGenerator.kt              # EXISTING: pascalCase()/camelCase() utils
├── src/commonTest/kotlin/io/codenode/kotlincompiler/generator/
│   ├── RuntimeFlowGeneratorTest.kt          # NEW
│   ├── RuntimeControllerGeneratorTest.kt    # NEW
│   ├── RuntimeControllerInterfaceGeneratorTest.kt  # NEW
│   ├── RuntimeControllerAdapterGeneratorTest.kt    # NEW
│   └── RuntimeViewModelGeneratorTest.kt     # NEW

graphEditor/
├── src/jvmMain/kotlin/io/codenode/grapheditor/save/
│   └── ModuleSaveService.kt                 # MODIFIED: call new generators
└── src/jvmTest/kotlin/io/codenode/grapheditor/save/
    └── ModuleSaveServiceTest.kt             # MODIFIED: test new file generation
```

**Structure Decision**: Existing multi-module KMP structure. New generators go in `kotlinCompiler` module (following existing pattern). Integration wiring in `graphEditor` module's `ModuleSaveService`.

## Implementation Approach

### Generator Pattern

Each generator follows the established `FlowKtGenerator` pattern:

```kotlin
class RuntimeFlowGenerator {
    fun generate(flowGraph: FlowGraph, generatedPackage: String, usecasesPackage: String): String
}
```

- Input: `FlowGraph` model + package names
- Output: String of generated Kotlin source code
- String-based generation using `buildString` (not KotlinPoet)

### Direct Runtime Instantiation (No Component Classes)

The generated Flow class directly creates runtime instances using `CodeNodeFactory` methods and passes tick function references from the user's stub files. This eliminates the need for hand-written Component classes.

**For each node**, the Flow class:
1. Imports the tick val from `{usecasesPackage}.logicmethods.{nodeName}Tick`
2. Creates the appropriate runtime via `CodeNodeFactory.create*()`, passing the tick val
3. For sink nodes: creates `MutableStateFlow` properties for each input port, wraps the user's tick function to also update the StateFlows

**Runtime selection based on port counts** (from R4):
- Generator (0 in, 2 out) → `CodeNodeFactory.createTimedOut2Generator(tick = timerEmitterTick)`
- Sink (2 in, 0 out) → `CodeNodeFactory.createIn2Sink(consume = { a, b -> _aFlow.value = a; _bFlow.value = b; displayReceiverTick(a, b) })`
- Transformer (1 in, 1 out) → `CodeNodeFactory.createContinuousTransformer(transform = transformerTick)`

**Generated Flow class structure** (StopWatch2 example):
```kotlin
class StopWatch2Flow {
    // Observable state for sink ports
    private val _seconds = MutableStateFlow(0)
    val secondsFlow: StateFlow<Int> = _seconds.asStateFlow()
    private val _minutes = MutableStateFlow(0)
    val minutesFlow: StateFlow<Int> = _minutes.asStateFlow()

    // Runtime instances created with tick function references
    internal val timerEmitter = CodeNodeFactory.createTimedOut2Generator<Int, Int>(
        name = "TimerEmitter", tickIntervalMs = 1000L, tick = timerEmitterTick
    )
    internal val displayReceiver = CodeNodeFactory.createIn2Sink<Int, Int>(
        name = "DisplayReceiver",
        consume = { seconds, minutes ->
            _seconds.value = seconds; _minutes.value = minutes
            displayReceiverTick(seconds, minutes)
        }
    )

    suspend fun start(scope: CoroutineScope) { ... }
    fun stop() { ... }
    fun reset() { /* zero all MutableStateFlows */ }
    private fun wireConnections() {
        // 2-input sink: inputChannel1/inputChannel2; 2-output generator: outputChannel1/outputChannel2
        displayReceiver.inputChannel1 = timerEmitter.outputChannel1
        displayReceiver.inputChannel2 = timerEmitter.outputChannel2
    }
}
```

### Observable State Resolution

```kotlin
fun getObservableStateProperties(flowGraph: FlowGraph): List<ObservableProperty>

data class ObservableProperty(
    val name: String,           // camelCase property name (e.g., "seconds")
    val typeName: String,       // e.g., "Int", "String"
    val sourceNodeName: String, // Node name for KDoc
    val sourcePortName: String, // Port name for KDoc
    val defaultValue: String    // e.g., "0" for Int, "\"\"" for String
)
```

Algorithm:
1. Filter `getAllCodeNodes()` for sink nodes (nodes with inputs, no outputs)
2. Collect all input ports from sink nodes
3. Check for name collisions across sinks
4. If collision: disambiguate with `{nodeName}{PortName}` in camelCase
5. Map port `dataType.simpleName` to Kotlin type name (default "Any")
6. Determine default value for MutableStateFlow initialization

### Connection Wiring Resolution

For each `Connection` in `FlowGraph.connections`:
1. Resolve source/target nodes via `findNode()`
2. Determine source port index within `node.outputPorts`
3. Determine target port index within `node.inputPorts`
4. Map indices to runtime channel property names:
   - 1 output: `outputChannel`; 2+ outputs: `outputChannel1`/`outputChannel2`/`outputChannel3`
   - 1 input: `inputChannel`; 2+ inputs: `inputChannel1`/`inputChannel2`/`inputChannel3`
5. Generate: `{targetRuntime}.{inputProp} = {sourceRuntime}.{outputProp}`

### ModuleSaveService Integration

After existing `.flow.kt` generation (line ~117), add:
```kotlin
// Generate runtime files (always overwrite in generated package)
generateRuntimeFiles(flowGraph, moduleDir, generatedPackage, usecasesPackage, filesCreated)
```

New private method instantiates all 5 generators and writes to `generated/` directory.

## Key Reference Files

| Purpose | File |
|---------|------|
| Generator pattern | `kotlinCompiler/.../generator/FlowKtGenerator.kt` |
| Stub generator | `kotlinCompiler/.../generator/ProcessingLogicStubGenerator.kt` |
| String utils | `kotlinCompiler/.../generator/KotlinCodeGenerator.kt` |
| Save orchestration | `graphEditor/.../save/ModuleSaveService.kt` |
| Reference: Flow | `StopWatch/.../generated/StopWatchFlow.kt` |
| Reference: Controller | `StopWatch/.../generated/StopWatchController.kt` |
| Reference: Interface | `StopWatch/.../generated/StopWatchControllerInterface.kt` |
| Reference: Adapter | `StopWatch/.../generated/StopWatchControllerAdapter.kt` |
| Reference: ViewModel | `StopWatch/.../generated/StopWatchViewModel.kt` |
| FlowGraph model | `fbpDsl/.../model/FlowGraph.kt` |
| CodeNode model | `fbpDsl/.../model/CodeNode.kt` |
| Port model | `fbpDsl/.../model/Port.kt` |
| Connection model | `fbpDsl/.../model/Connection.kt` |
