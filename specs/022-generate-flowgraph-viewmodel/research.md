# Research: Generate FlowGraph ViewModel

**Feature**: 022-generate-flowgraph-viewmodel
**Date**: 2026-02-19

## Research Topics

### R1: Observable State Discovery Strategy

**Decision**: Derive observable state properties from **sink node input ports**. Each sink input port produces one StateFlow property in the ControllerInterface. The port name becomes the property name, and the port's data type becomes the StateFlow type parameter.

**Rationale**: Sink nodes are the natural UI boundary in the FBP architecture - they receive data that needs to be displayed. Deriving from their input ports uses existing FlowGraph metadata (port names and types) without requiring additional configuration keys or source-file inspection. Port data types will be made selectable from IP types in the graphEditor.

**StopWatch example**:
- DisplayReceiver (SINK) has input ports: `seconds` (Int), `minutes` (Int)
- Generated ControllerInterface: `val seconds: StateFlow<Int>`, `val minutes: StateFlow<Int>`
- Note: These names differ from the current hand-written interface (`elapsedSeconds`, `elapsedMinutes`). The hand-written files and tests will be updated to use port-derived names as part of US2.

**Alternatives considered**:
1. **`_observableState` configuration key** - Rejected per user clarification. Would require additional config not present in the FlowGraph model. Extra maintenance burden.
2. **Inspect component source files** for StateFlow patterns - Rejected: fragile regex parsing, requires source file access at generation time, breaks if naming changes.

### R2: Package Location for Moved/Generated ViewModel Files

**Decision**: Place ViewModel, ControllerInterface, and ControllerAdapter in the `generated/` subpackage within the flow module (e.g., `io.codenode.stopwatch.generated`), alongside the existing Controller and Flow classes.

**Rationale**: All four classes (Controller, ControllerInterface, ControllerAdapter, ViewModel) will eventually be generated by ModuleGenerator. Keeping them together in the `generated/` package makes regeneration simple (overwrite entire directory) and communicates that these files should not be hand-edited.

**Alternatives considered**:
1. **Separate `viewmodel/` subpackage** - Rejected: creates artificial separation from the Controller they depend on. Complicates regeneration.
2. **Root module package** - Rejected: mixes generated code with hand-written component code.

### R3: StopWatch Build Dependencies for ViewModel

**Decision**: Add `lifecycle-viewmodel-compose:2.8.0` to StopWatch's `commonMain` dependencies.

**Rationale**: The ViewModel class extends `androidx.lifecycle.ViewModel`, which requires the `lifecycle-viewmodel-compose` dependency. StopWatch currently only has `lifecycle-runtime-compose:2.8.0`. Since the ViewModel will live in StopWatch after the move, this dependency must be available. Apache 2.0 licensed (JetBrains), KMP-compatible.

### R4: Code Generation Pattern

**Decision**: Extend `ModuleGenerator` with three new methods using the existing `buildString` pattern: `generateControllerInterfaceClass()`, `generateControllerAdapterClass()`, `generateViewModelClass()`.

**Rationale**: The existing `generateControllerClass()` and `generateFlowGraphClass()` use `buildString {}` with `appendLine()`. Consistent, readable, and no additional dependencies needed.

**Alternatives considered**:
1. **KotlinPoet** - Available but overkill for these simple facade/delegation classes.
2. **Separate generator class** - Rejected: methods are small and logically belong with the other generation methods in ModuleGenerator.

### R5: Handling Multiple Sink Nodes (FR-009)

**Decision**: Prefix property names with the sink node name (camelCase) when multiple sink nodes contribute observable state. Single-sink case uses unprefixed port names.

**Rationale**: Follows FR-009 from the spec. Avoids naming collisions while keeping the common single-sink case clean.

**Example with two sinks**:
- DisplayReceiver: ports `seconds`, `minutes` → `displayReceiverSeconds`, `displayReceiverMinutes`
- AlertReceiver: port `alertLevel` → `alertReceiverAlertLevel`

**Single sink**: ports `seconds`, `minutes` → `seconds`, `minutes` (no prefix)

### R6: Port Data Type Resolution

**Decision**: Use `Port.dataType` (KClass) to determine the StateFlow type parameter. When the port type is `Any::class` (the current default), use `Any` as the type parameter.

**Rationale**: The spec states port types will be updated to be selectable from IP types in the graphEditor. For the initial implementation, the generator uses whatever `Port.dataType` provides. If it's `Any::class`, the generated StateFlow is `StateFlow<Any>`. As port types are populated with concrete types (Int, String, etc.), the generated code automatically uses the correct types.

**StopWatch update needed**: The StopWatch FlowGraph definition currently uses `Any::class` for all ports. For the generated ControllerInterface to produce `StateFlow<Int>`, the port types in `RegenerateStopWatch.kt` and `StopWatch.flow.kt` must be updated to `Int::class`.

### R7: Controller StateFlow Wiring (Sink-Based)

**Decision**: The generated Controller references **sink component** StateFlow properties using the naming convention `{portName}Flow`. The Controller property `val seconds: StateFlow<Int>` wires to `flow.displayReceiver.secondsFlow`.

**Rationale**: Since observable state is derived from sink input ports, the Controller should source its StateFlows from the corresponding sink component. The naming convention `{portName}Flow` connects the port name to the component's StateFlow property.

**Impact on existing components**: The DisplayReceiverComponent must rename its StateFlow properties:
- `displayedSecondsFlow` → `secondsFlow` (matching port name `seconds`)
- `displayedMinutesFlow` → `minutesFlow` (matching port name `minutes`)

Similarly, the StopWatchController must be updated:
- `flow.timerEmitter.elapsedSecondsFlow` → `flow.displayReceiver.secondsFlow`
- `flow.timerEmitter.elapsedMinutesFlow` → `flow.displayReceiver.minutesFlow`

### R8: Existing Test Updates

**Decision**: Tests are updated in two phases:
1. **US1 (Move)**: Move test files with current names (`elapsedSeconds`, `elapsedMinutes`). Tests pass with existing names.
2. **US2 (Generate Interface)**: Update hand-written ControllerInterface, ControllerAdapter, ViewModel, FakeStopWatchController, and StopWatchViewModelTest to use port-derived names (`seconds`, `minutes`). Then verify generator output matches.

**Rationale**: Decoupling the move from the rename avoids a large atomic change. US1 proves the module structure works. US2 proves the generator produces correct output.

### R9: Component StateFlow Naming Convention

**Decision**: Sink component classes MUST expose a `{portName}Flow: StateFlow<Type>` property for each input port that contributes to observable state.

**Convention**: For a sink input port named `seconds` of type `Int`:
- Component property: `val secondsFlow: StateFlow<Int>`
- MutableStateFlow backing: `private val _seconds = MutableStateFlow(0)`

**Rationale**: This convention allows the generator to construct Controller property references deterministically: `flow.{sinkNodeCamelCase}.{portName}Flow`. No additional metadata or inspection needed.

**US5 gap**: This naming convention is not enforced by the FlowGraph model. Components must follow it manually. US5 documents this as a convention that could be formalized.
