# Undefined Inputs for ViewModel Generation

**Feature**: 022-generate-flowgraph-viewmodel
**Created**: 2026-02-19
**Purpose**: Document all metadata gaps between the current FlowGraph schema and what the ViewModel layer generator needs, with recommended conventions or DSL extensions for each gap.

## Summary

The ViewModel layer generator (`ModuleGenerator`) derives observable state properties from sink node input ports in the FlowGraph. While this convention-based approach works for the StopWatch case, five metadata gaps exist where the generator must rely on conventions, heuristics, or hardcoded behavior because the FlowGraph schema does not explicitly provide the needed information.

| # | Gap | Severity | Current Workaround |
|---|-----|----------|--------------------|
| 1 | Port data types default to `Any::class` | High | Manual fix in RegenerateStopWatch.kt |
| 2 | Component StateFlow naming convention not enforced | Medium | Convention: `{portName}Flow` |
| 3 | Reset behavior is hardcoded | Medium | Generator hardcodes `flow.timerEmitter.reset()` |
| 4 | No port filtering mechanism | Low | All sink input ports become observable state |
| 5 | StateFlow initial values not derivable | Low | Components provide defaults internally |

---

## Gap 1: Port Data Types Default to `Any::class`

### Problem

`Port<T>` has a `dataType: KClass<T>` field, but many FlowGraph definitions use `Any::class` as a placeholder. The generator reads `dataType.simpleName` to produce the StateFlow type parameter (e.g., `StateFlow<Int>`). When the port type is `Any`, the generated code produces `StateFlow<Any>`, which is not useful for UI binding.

**Current schema** (`Port.kt:51`):
```kotlin
data class Port<T : Any>(
    val dataType: KClass<T>,
    ...
)
```

### Current Workaround

`RegenerateStopWatch.kt` was manually updated (T011) to set `dataType = Int::class` on all four StopWatch ports. This is a per-graph manual fix, not a systemic solution.

### Impact on Generated Code

When `dataType = Any::class`:
- Generated interface: `val seconds: StateFlow<Any>` (not type-safe)
- Compose UI must cast: `val seconds = viewModel.seconds.collectAsState().value as Int`

When `dataType = Int::class`:
- Generated interface: `val seconds: StateFlow<Int>` (type-safe)
- Compose UI works directly: `val seconds by viewModel.seconds.collectAsState()`

### Recommended Solution

**Port types selectable from IP types in graphEditor.** When the user creates or edits a port in the graphEditor, they select the data type from the available Information Packet types. This ensures every port has a concrete type before code generation.

**Validation**: The generator should emit a warning or error when it encounters `Any::class` on a sink input port, since the generated StateFlow would not be type-safe.

**DSL extension** (future): The `.flow.kts` DSL should persist the selected port type so it round-trips through save/load:
```kotlin
inputPort("seconds", Int::class)
inputPort("minutes", Int::class)
```

---

## Gap 2: Component StateFlow Naming Convention Not Enforced

### Problem

The generator assumes that each sink component exposes a StateFlow named `{portName}Flow` for each of its input ports. For example, a sink with an input port named `seconds` is expected to have a property `secondsFlow: StateFlow<Int>`.

This convention is **not enforced** by the model or runtime. It depends entirely on the component author following the naming pattern. If a component names its StateFlow differently (e.g., `displayedSecondsFlow` or `currentSeconds`), the generated Controller code will fail to compile.

**Generated Controller code** (`ModuleGenerator.kt:663`):
```kotlin
val seconds: StateFlow<Int> = flow.displayReceiver.secondsFlow
```

### Current Workaround

The StopWatch `DisplayReceiverComponent` was manually renamed (T013) to follow the `{portName}Flow` convention:
- `displayedSecondsFlow` -> `secondsFlow`
- `displayedMinutesFlow` -> `minutesFlow`

### Impact

If a hand-written component does not follow the naming convention, the generated Controller will reference a non-existent property, causing a compile error.

### Recommended Solution

**Convention with documentation**: Establish `{portName}Flow: StateFlow<T>` as the required naming convention for sink component StateFlow properties. Document this in the component authoring guide.

**Runtime enforcement** (future): The typed runtime stubs (`In2SinkRuntime`, etc.) could automatically expose StateFlow properties following this convention, removing the need for component authors to manually create them. The runtime would provide:
```kotlin
// Auto-generated by In2SinkRuntime
val secondsFlow: StateFlow<Int>   // from inputChannel1
val minutesFlow: StateFlow<Int>   // from inputChannel2
```

This would make the convention a built-in guarantee rather than a documentation-only rule.

---

## Gap 3: Reset Behavior Is Hardcoded

### Problem

The generated Controller's `reset()` method contains hardcoded references to specific components that have reset logic:

```kotlin
fun reset(): FlowGraph {
    wasRunningBeforePause = false
    flow.timerEmitter.reset()  // <-- Hardcoded component reference
    return stop()
}
```

The FlowGraph schema has no metadata declaring:
1. Which components support a `reset()` method
2. What "reset" means for each component (clear accumulated state, rewind to initial position, etc.)
3. The order in which components should be reset

### Current Workaround

The generator hardcodes `flow.timerEmitter.reset()` because it knows, from the hand-written StopWatch code, that `TimerEmitterComponent` has a `reset()` method. This does not generalize to other FlowGraphs.

### Impact

For any FlowGraph other than StopWatch, the generator would either:
- Omit reset logic entirely (losing functionality), or
- Reference non-existent `reset()` methods (compile error)

### Recommended Solution

**Node-level `resettable` flag on CodeNode** (DSL extension):
```kotlin
data class CodeNode(
    ...
    val resettable: Boolean = false
)
```

When `resettable = true`, the generator emits `flow.{componentCamelCase}.reset()` in the Controller's `reset()` method. The component is responsible for implementing a `reset()` method.

**Alternative**: A `ResetPolicy` enum on the FlowGraph level:
```kotlin
enum class ResetPolicy {
    STOP_ONLY,           // reset() just calls stop()
    RESET_ALL_GENERATORS // reset() calls reset() on every GENERATOR component, then stop()
}
```

The simplest approach for now is `RESET_ALL_GENERATORS` as the default, since generators are the stateful source nodes that accumulate state (counters, timers, etc.). Sinks and transformers are typically stateless pass-through.

---

## Gap 4: No Port Filtering Mechanism

### Problem

The generator's `collectSinkPortProperties()` treats **every** input port on every sink node as an observable state property. There is no mechanism to exclude ports that are:
- **Internal/debug**: Ports used for logging, metrics, or internal coordination
- **Non-UI**: Ports that drive side effects (file writes, network calls) rather than UI state
- **Transient**: Ports that carry event signals rather than persistent state

### Current Workaround

All sink input ports produce observable state. For the StopWatch, this happens to be correct (both `seconds` and `minutes` are UI-facing). But a more complex flow might have a sink with a `debugMetrics` port that should not appear in the ViewModel.

### Impact

Without filtering, the generated ControllerInterface, Adapter, and ViewModel will include unnecessary properties. This adds noise to the UI contract and may expose internal implementation details.

### Recommended Solution

**Port-level `observable` flag** (DSL extension):
```kotlin
data class Port<T : Any>(
    ...
    val observable: Boolean = true  // default: all ports are observable
)
```

Setting `observable = false` excludes the port from the generated ViewModel layer. The graphEditor would provide a checkbox or toggle for this property.

**Default behavior**: All sink input ports are observable unless explicitly excluded. This preserves backward compatibility and the common case where most sink ports are UI-relevant.

**Alternative**: An `internal` flag or `visibility` enum (`PUBLIC`, `INTERNAL`, `HIDDEN`) could serve a broader purpose beyond just ViewModel generation, applying also to documentation generation and API surface control.

---

## Gap 5: StateFlow Initial Values Not Derivable from FlowGraph

### Problem

Every `StateFlow<T>` requires an initial value (e.g., `MutableStateFlow(0)` for `StateFlow<Int>`). The FlowGraph schema does not declare what the initial value should be for each observable state property.

The `Port` model has a `defaultValue: T?` field (`Port.kt:28`), but:
1. It is typed as the port's generic parameter, not serializable
2. It is marked `@Transient` on `CodeNode.inputPorts` (lost during serialization)
3. It is not commonly populated in practice

### Current Workaround

The generated Controller delegates to the component's StateFlow, which provides its own initial value:
```kotlin
// In DisplayReceiverComponent:
private val _seconds = MutableStateFlow(0)  // Component provides initial value

// In generated Controller:
val seconds: StateFlow<Int> = flow.displayReceiver.secondsFlow  // Delegates to component
```

The generator does not need to know the initial value because it wires to the component's existing StateFlow rather than creating a new one.

### Impact

**Low impact for the current architecture.** Since the Controller delegates to component StateFlows, the initial value is the component author's responsibility. The generated ControllerInterface, Adapter, and ViewModel are pure delegation layers that never construct their own MutableStateFlows for sink-derived properties.

However, if the generator ever needs to create standalone StateFlows (e.g., for preview/mock implementations), it would need a way to derive sensible defaults.

### Recommended Solution

**Rely on the existing delegation pattern.** The component owns the MutableStateFlow and its initial value. The generated code delegates to it. This is architecturally sound because:
- The component is the domain expert on sensible defaults
- Initial values may depend on runtime context (locale, user preferences, etc.)
- The ViewModel layer should not duplicate or override component state

**Future enhancement**: If mock/preview ViewModel generation is needed, use type-based defaults:
- `Int` -> `0`
- `String` -> `""`
- `Boolean` -> `false`
- `Double` -> `0.0`
- Other -> requires explicit `defaultValue` on the Port

---

## Recommendations Summary

| Gap | Recommended Action | Timeline |
|-----|--------------------|----------|
| 1. Port data types | Make selectable in graphEditor; validate at generation time | Next feature (graphEditor enhancement) |
| 2. StateFlow naming | Document convention; consider runtime auto-exposure | Convention now, runtime enforcement later |
| 3. Reset behavior | Add `resettable` flag to CodeNode or use `RESET_ALL_GENERATORS` default | Next generator iteration |
| 4. Port filtering | Add `observable` flag to Port model | When first needed (non-UI port case) |
| 5. Initial values | Keep delegation pattern; add type-based defaults for mocks | Only if mock generation needed |

### Priority Order

1. **Gap 1** (Port data types) is the highest priority because `Any::class` ports produce unusable generated code. The graphEditor type selector is the right fix.
2. **Gap 3** (Reset behavior) is next because it prevents the Controller generator from working on flows other than StopWatch.
3. **Gap 2** (StateFlow naming) is medium priority - it works via convention today but should be enforced by the runtime to prevent silent breakage.
4. **Gap 4** (Port filtering) and **Gap 5** (Initial values) are low priority and can be addressed when the first real-world case demands them.
