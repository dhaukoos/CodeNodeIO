# Implementation Plan: Node Control Extraction

**Branch**: `013-node-control-extraction` | **Date**: 2026-02-13 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/013-node-control-extraction/spec.md`

## Summary

Extract common node lifecycle control (nodeControlJob, executionState management, start/stop/pause/resume methods) from TimerEmitterComponent and DisplayReceiverComponent into the base CodeNode class. This consolidates job management logic into a single source of truth, reducing code duplication and establishing consistent lifecycle patterns for all FBP nodes.

## Technical Context

**Language/Version**: Kotlin 2.1.21 (KMP - Kotlin Multiplatform)
**Primary Dependencies**: kotlinx-coroutines 1.8.0, kotlinx-serialization 1.6.0
**Storage**: N/A (in-memory FlowGraph models)
**Testing**: kotlin.test with kotlinx-coroutines-test (runTest, advanceTimeBy)
**Target Platform**: JVM (primary), with KMP common code for future multiplatform
**Project Type**: Multiplatform library (KMP)
**Performance Goals**: N/A (refactoring task, no performance changes expected)
**Constraints**: All existing tests must pass without modification
**Scale/Scope**: 3 files modified (CodeNode.kt, TimerEmitterComponent.kt, DisplayReceiverComponent.kt)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| **I. Code Quality First** | ✅ PASS | Consolidates duplicate code into single source of truth |
| **II. Test-Driven Development** | ✅ PASS | All 7+ existing tests serve as regression suite; new lifecycle tests will be added |
| **III. User Experience Consistency** | ✅ N/A | Internal refactoring, no user-facing changes |
| **IV. Performance Requirements** | ✅ PASS | No performance impact expected |
| **V. Observability & Debugging** | ✅ PASS | Job lifecycle in single location aids debugging |
| **Licensing** | ✅ PASS | No new dependencies; Apache 2.0 compatible |

**Re-check after Phase 1**: All gates still pass. No new dependencies or complexity introduced.

## Project Structure

### Documentation (this feature)

```text
specs/013-node-control-extraction/
├── plan.md              # This file
├── research.md          # Technical findings and decisions
├── data-model.md        # Entity changes and relationships
├── quickstart.md        # Step-by-step implementation guide
├── checklists/          # Quality validation
│   └── requirements.md  # Specification completeness checklist
└── tasks.md             # Implementation tasks (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
fbpDsl/
├── src/commonMain/kotlin/io/codenode/fbpdsl/model/
│   ├── CodeNode.kt              # Modified: Add nodeControlJob, start(), stop(), pause(), resume()
│   └── ExecutionState.kt        # Unchanged: Existing enum is sufficient
└── src/commonTest/kotlin/io/codenode/fbpdsl/model/
    └── CodeNodeLifecycleTest.kt # New: Lifecycle control tests

StopWatch/
├── src/commonMain/kotlin/io/codenode/stopwatch/usecases/
│   ├── TimerEmitterComponent.kt    # Modified: Delegate to CodeNode
│   └── DisplayReceiverComponent.kt # Modified: Delegate to CodeNode
└── src/commonTest/kotlin/io/codenode/stopwatch/usecases/
    ├── TimerEmitterComponentTest.kt    # Unchanged: Regression tests
    ├── DisplayReceiverComponentTest.kt # Unchanged: Regression tests
    └── ChannelIntegrationTest.kt       # Unchanged: E2E tests
```

**Structure Decision**: Existing KMP multiplatform structure maintained. Changes are isolated to model layer (fbpDsl) and use case layer (StopWatch).

## Complexity Tracking

No constitution violations. This is a pure refactoring task that reduces complexity:

| Metric | Before | After |
|--------|--------|-------|
| Job management locations | 2 (components) | 1 (CodeNode) |
| start() implementations | 2 | 1 (shared) |
| stop() implementations | 2 | 1 (shared) |
| pause()/resume() implementations | 0 | 1 (new capability) |
| Lines of duplicate code | ~40 | 0 |

## Implementation Approach

### Phase 1: Add Lifecycle Control to CodeNode

1. Add `@Transient var nodeControlJob: Job? = null` to CodeNode
2. Add `suspend fun start(scope: CoroutineScope, processingBlock: suspend () -> Unit)` method
3. Add `fun stop()` method
4. Add `fun pause()` method (RUNNING → PAUSED)
5. Add `fun resume()` method (PAUSED → RUNNING)
6. Write CodeNodeLifecycleTest with 9 test cases (start, stop, pause, resume + edge cases)

### Phase 2: Refactor TimerEmitterComponent

1. Add `var codeNode: CodeNode?` reference
2. Refactor `start()` to delegate job management to CodeNode
3. Refactor `stop()` to delegate to CodeNode
4. Retain timer-specific business logic (tick loop, state flows)
5. Verify all TimerEmitterComponentTest tests pass

### Phase 3: Refactor DisplayReceiverComponent

1. Add `var codeNode: CodeNode?` reference
2. Refactor `start()` to delegate job management to CodeNode
3. Refactor `stop()` to delegate to CodeNode
4. Retain receiver-specific business logic (channel iteration, state flows)
5. Verify all DisplayReceiverComponentTest tests pass

### Phase 4: Integration Verification

1. Run full StopWatch test suite
2. Verify ChannelIntegrationTest passes
3. Run fbpDsl test suite
4. Manual verification of StopWatch flow execution

## Design Decisions

See [research.md](./research.md) for full analysis.

**Key Decision**: Use `@Transient var nodeControlJob: Job?` in data class
- **Rationale**: Consistent with existing pattern (`@Transient` fields for ports, processingLogic)
- **Alternative Rejected**: Wrapper class - adds unnecessary indirection

**Key Decision**: Components use composition (codeNode reference) not inheritance
- **Rationale**: CodeNode is already a data class; components implement ProcessingLogic
- **Alternative Rejected**: Inheritance - not possible with data class
